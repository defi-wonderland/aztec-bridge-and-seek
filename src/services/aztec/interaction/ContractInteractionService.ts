import { 
  Contract, 
  AztecAddress, 
  Fr, 
  TxHash,
  PXE,
  Wallet
} from '@aztec/aztec.js';
import { ContractArtifact } from '@aztec/stdlib/abi';
import { 
  AztecContractFunction, 
  AztecFunctionParameter,
  AztecParameterType 
} from '../../../types';
import { FunctionUIConfig, InputFieldConfig } from '../ui/ContractUIGenerator';

/**
 * Function execution input parameters
 */
export interface FunctionExecutionInputs {
  [parameterName: string]: unknown;
}

/**
 * Function execution result
 */
export interface FunctionExecutionResult {
  /** Whether execution was successful */
  success: boolean;
  /** Transaction hash for private/public functions */
  txHash?: TxHash;
  /** Return value for unconstrained functions */
  returnValue?: unknown;
  /** Error message if execution failed */
  error?: string;
  /** Gas used (if available) */
  gasUsed?: bigint;
  /** Block number where transaction was included */
  executionBlock?: number;
}

/**
 * Contract deployment result
 */
export interface ContractDeploymentResult {
  /** Whether deployment was successful */
  success: boolean;
  /** Deployed contract address */
  contractAddress?: AztecAddress;
  /** Transaction hash */
  txHash?: TxHash;
  /** Error message if deployment failed */
  error?: string;
  /** Block number where contract was deployed */
  deploymentBlock?: number;
}

/**
 * Parameter validation error
 */
export interface ParameterValidationError {
  parameterName: string;
  expectedType: AztecParameterType;
  receivedValue: unknown;
  message: string;
}

/**
 * Service for executing Aztec contract functions
 * 
 * This service handles the execution of Aztec contract functions using
 * UI configurations generated by ContractUIGenerator. It manages parameter
 * parsing, validation, and interaction with the Aztec network.
 * 
 * @example
 * ```typescript
 * const service = new ContractInteractionService(pxe, wallet);
 * 
 * // Execute a function
 * const result = await service.executeFunction(
 *   contractAddress,
 *   functionConfig,
 *   { amount: "100", recipient: "0x..." }
 * );
 * 
 * // Deploy a contract
 * const deployment = await service.deployContract(
 *   artifact,
 *   initializerConfig,
 *   { initial_supply: "1000000" }
 * );
 * ```
 */
export class ContractInteractionService {
  private pxe: PXE;
  private wallet: Wallet;

  constructor(pxe: PXE, wallet: Wallet) {
    this.pxe = pxe;
    this.wallet = wallet;
  }

  /**
   * Execute a contract function
   * 
   * @param contractAddress - Address of the deployed contract
   * @param functionConfig - UI configuration for the function
   * @param inputs - User input values
   * @returns Execution result
   */
  async executeFunction(
    contractAddress: AztecAddress,
    functionConfig: FunctionUIConfig,
    inputs: FunctionExecutionInputs
  ): Promise<FunctionExecutionResult> {
    try {
      // Validate inputs
      const validationErrors = this.validateInputs(functionConfig, inputs);
      if (validationErrors.length > 0) {
        return {
          success: false,
          error: `Validation errors: ${validationErrors.map(e => e.message).join(', ')}`,
        };
      }

      // Parse inputs to Aztec types
      const parsedInputs = this.parseInputsToAztecTypes(functionConfig, inputs);

      // Get contract instance
      const contract = await Contract.at(contractAddress, functionConfig.function.abi, this.wallet);

      // Execute based on function visibility
      switch (functionConfig.function.visibility) {
        case 'private':
          return await this.executePrivateFunction(contract, functionConfig, parsedInputs);
        
        case 'public':
          return await this.executePublicFunction(contract, functionConfig, parsedInputs);
        
        case 'unconstrained':
          return await this.executeUnconstrainedFunction(contract, functionConfig, parsedInputs);
        
        default:
          return {
            success: false,
            error: `Unsupported function visibility: ${functionConfig.function.visibility}`,
          };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown execution error',
      };
    }
  }

  /**
   * Deploy a new contract
   * 
   * @param artifact - Contract artifact
   * @param initializerConfig - Initializer function configuration (if any)
   * @param inputs - Initializer input values
   * @returns Deployment result
   */
  async deployContract(
    artifact: ContractArtifact,
    initializerConfig?: FunctionUIConfig,
    inputs?: FunctionExecutionInputs
  ): Promise<ContractDeploymentResult> {
    try {
      let parsedInputs: unknown[] = [];

      // Parse initializer inputs if provided
      if (initializerConfig && inputs) {
        const validationErrors = this.validateInputs(initializerConfig, inputs);
        if (validationErrors.length > 0) {
          return {
            success: false,
            error: `Initializer validation errors: ${validationErrors.map(e => e.message).join(', ')}`,
          };
        }
        parsedInputs = this.parseInputsToAztecTypes(initializerConfig, inputs);
      }

      // Deploy contract
      const deploymentTx = Contract.deploy(this.wallet, artifact, ...parsedInputs);
      const receipt = await deploymentTx.send().wait();

      // Get block number from receipt
      const deploymentBlock = receipt.blockNumber;

      return {
        success: true,
        contractAddress: receipt.contractAddress!,
        txHash: receipt.txHash,
        deploymentBlock,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown deployment error',
      };
    }
  }

  /**
   * Validate function inputs against parameter definitions
   * 
   * @param functionConfig - Function configuration
   * @param inputs - User inputs to validate
   * @returns Array of validation errors
   * @private
   */
  private validateInputs(
    functionConfig: FunctionUIConfig,
    inputs: FunctionExecutionInputs
  ): ParameterValidationError[] {
    const errors: ParameterValidationError[] = [];

    for (const inputField of functionConfig.inputFields) {
      const parameter = inputField.parameter;
      const value = inputs[parameter.name];

      // Check required fields
      if (inputField.validation.required && (value === undefined || value === null || value === '')) {
        errors.push({
          parameterName: parameter.name,
          expectedType: parameter.type,
          receivedValue: value,
          message: `Parameter '${parameter.name}' is required`,
        });
        continue;
      }

      // Skip validation for optional empty fields
      if (!inputField.validation.required && (value === undefined || value === null || value === '')) {
        continue;
      }

      // Validate type-specific constraints
      const typeValidationError = this.validateParameterType(parameter, value);
      if (typeValidationError) {
        errors.push(typeValidationError);
      }
    }

    return errors;
  }

  /**
   * Validate a specific parameter against its type constraints
   * 
   * @param parameter - Parameter definition
   * @param value - Value to validate
   * @returns Validation error if invalid, null if valid
   * @private
   */
  private validateParameterType(
    parameter: AztecFunctionParameter,
    value: unknown
  ): ParameterValidationError | null {
    switch (parameter.type) {
      case 'AztecAddress':
      case 'Field':
        if (typeof value !== 'string' || !this.isValidHexString(value as string, 64)) {
          return {
            parameterName: parameter.name,
            expectedType: parameter.type,
            receivedValue: value,
            message: `${parameter.name} must be a valid hex string (0x + 64 hex characters)`,
          };
        }
        break;

      case 'u8':
      case 'u16':
      case 'u32':
      case 'i8':
      case 'i16':
      case 'i32':
        const num = Number(value);
        if (isNaN(num) || !Number.isInteger(num)) {
          return {
            parameterName: parameter.name,
            expectedType: parameter.type,
            receivedValue: value,
            message: `${parameter.name} must be a valid integer`,
          };
        }
        break;

      case 'u64':
      case 'u128':
      case 'i64':
      case 'i128':
        try {
          BigInt(value as string);
        } catch {
          return {
            parameterName: parameter.name,
            expectedType: parameter.type,
            receivedValue: value,
            message: `${parameter.name} must be a valid big integer`,
          };
        }
        break;

      case 'bool':
        if (typeof value !== 'boolean' && value !== 'true' && value !== 'false') {
          return {
            parameterName: parameter.name,
            expectedType: parameter.type,
            receivedValue: value,
            message: `${parameter.name} must be a boolean value`,
          };
        }
        break;

      case 'string':
        if (typeof value !== 'string') {
          return {
            parameterName: parameter.name,
            expectedType: parameter.type,
            receivedValue: value,
            message: `${parameter.name} must be a string`,
          };
        }
        break;

      case 'array':
        if (!Array.isArray(value)) {
          // Try to parse as comma-separated string
          if (typeof value === 'string') {
            try {
              JSON.parse(`[${value}]`);
            } catch {
              return {
                parameterName: parameter.name,
                expectedType: parameter.type,
                receivedValue: value,
                message: `${parameter.name} must be a valid array or comma-separated values`,
              };
            }
          } else {
            return {
              parameterName: parameter.name,
              expectedType: parameter.type,
              receivedValue: value,
              message: `${parameter.name} must be an array`,
            };
          }
        }
        break;

      case 'struct':
        if (typeof value === 'string') {
          try {
            JSON.parse(value);
          } catch {
            return {
              parameterName: parameter.name,
              expectedType: parameter.type,
              receivedValue: value,
              message: `${parameter.name} must be valid JSON`,
            };
          }
        } else if (typeof value !== 'object' || value === null) {
          return {
            parameterName: parameter.name,
            expectedType: parameter.type,
            receivedValue: value,
            message: `${parameter.name} must be an object`,
          };
        }
        break;
    }

    return null;
  }

  /**
   * Parse user inputs to Aztec-compatible types
   * 
   * @param functionConfig - Function configuration
   * @param inputs - User inputs
   * @returns Array of parsed values
   * @private
   */
  private parseInputsToAztecTypes(
    functionConfig: FunctionUIConfig,
    inputs: FunctionExecutionInputs
  ): unknown[] {
    return functionConfig.inputFields.map(inputField => {
      const parameter = inputField.parameter;
      const value = inputs[parameter.name];

      return this.parseValueToAztecType(parameter.type, value);
    });
  }

  /**
   * Parse a single value to its corresponding Aztec type
   * 
   * @param type - Parameter type
   * @param value - Raw value to parse
   * @returns Parsed value
   * @private
   */
  private parseValueToAztecType(type: AztecParameterType, value: unknown): unknown {
    switch (type) {
      case 'Field':
        return Fr.fromString(value as string);

      case 'AztecAddress':
        return AztecAddress.fromString(value as string);

      case 'u8':
      case 'u16':
      case 'u32':
      case 'i8':
      case 'i16':
      case 'i32':
        return Number(value);

      case 'u64':
      case 'u128':
      case 'i64':
      case 'i128':
        return BigInt(value as string);

      case 'bool':
        if (typeof value === 'boolean') return value;
        return value === 'true' || value === true;

      case 'string':
        return String(value);

      case 'array':
        if (Array.isArray(value)) return value;
        if (typeof value === 'string') {
          // Parse comma-separated string
          return JSON.parse(`[${value}]`);
        }
        return [];

      case 'struct':
        if (typeof value === 'string') {
          return JSON.parse(value);
        }
        return value;

      default:
        return value;
    }
  }

  /**
   * Execute a private function
   * 
   * @param contract - Contract instance
   * @param functionConfig - Function configuration
   * @param parsedInputs - Parsed input values
   * @returns Execution result
   * @private
   */
  private async executePrivateFunction(
    contract: Contract,
    functionConfig: FunctionUIConfig,
    parsedInputs: unknown[]
  ): Promise<FunctionExecutionResult> {
    const tx = contract.methods[functionConfig.function.name](...parsedInputs);
    const receipt = await tx.send().wait();

    // Get block number from receipt
    const executionBlock = receipt.blockNumber;

    return {
      success: true,
      txHash: receipt.txHash,
      executionBlock,
    };
  }

  /**
   * Execute a public function
   * 
   * @param contract - Contract instance
   * @param functionConfig - Function configuration
   * @param parsedInputs - Parsed input values
   * @returns Execution result
   * @private
   */
  private async executePublicFunction(
    contract: Contract,
    functionConfig: FunctionUIConfig,
    parsedInputs: unknown[]
  ): Promise<FunctionExecutionResult> {
    const tx = contract.methods[functionConfig.function.name](...parsedInputs);
    const receipt = await tx.send().wait();

    // Get block number from receipt
    const executionBlock = receipt.blockNumber;

    return {
      success: true,
      txHash: receipt.txHash,
      executionBlock,
    };
  }

  /**
   * Execute an unconstrained function
   * 
   * @param contract - Contract instance
   * @param functionConfig - Function configuration
   * @param parsedInputs - Parsed input values
   * @returns Execution result
   * @private
   */
  private async executeUnconstrainedFunction(
    contract: Contract,
    functionConfig: FunctionUIConfig,
    parsedInputs: unknown[]
  ): Promise<FunctionExecutionResult> {
    const result = await contract.methods[functionConfig.function.name](...parsedInputs).simulate();

    return {
      success: true,
      returnValue: result,
    };
  }

  /**
   * Validate hex string format
   * 
   * @param value - Value to validate
   * @param expectedLength - Expected length of hex part (without 0x)
   * @returns Whether the hex string is valid
   * @private
   */
  private isValidHexString(value: string, expectedLength: number): boolean {
    if (!value.startsWith('0x')) return false;
    const hexPart = value.slice(2);
    return hexPart.length === expectedLength && /^[a-fA-F0-9]+$/.test(hexPart);
  }
}
