{
  "transpiled": true,
  "noir_version": "1.0.0-beta.7+0000000000000000000000000000000000000000",
  "name": "EasyPrivateVoting",
  "functions": [
    {
      "name": "add_to_tally_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "candidate",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2024020833944022298": {
            "error_kind": "string",
            "string": "Function add_to_tally_public can only be called internally"
          },
          "3557153117338734214": {
            "error_kind": "string",
            "string": "Vote has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_to_tally_public"
      ]
    },
    {
      "name": "cast_vote",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "candidate",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tb3djuzKcaZ9L/tYB8zI+MnwrQwGhuzRGAIEyZDlAT4YvvevGMyIN7uXK5td1fvE69HyXvGwSMbLv2Tyv377P3/6l//8t3/+81//79/+47d/+l//9du//P3Pf/nLn//tn//yt3/94z/+/Le/Pv72v347zv/TaPz2T+0Pjz/9+rMf8882/6T5Z59/8vxT5p86/7T556zXZz2e9XjW41mPZz2e9XjW41mPZz2e9XjWk1lPZj2Z9WTWk1lPZj2Z9WTWk1lPZj2d9XTW01lPZz2d9XTW01lPZz2d9XTWs1nPZj2b9WzWs1nPZj2b9WzWs1nPZr0x641Zb8x6Y9Ybs96Y9casN2a9MeuNWc8f9eT8s80/af7Z5588/5T5p84/bf455p8ef9JxzD/b/PNRT88/+/yT558y/9T5p80/H/X8/PNcvv6AdiS0BEroCZxw/mo7QRMsYSSclccD6EhoCWfldkJP4IRHZToVpAmWMBJ8wtk0F7QESugJnJCVe1buWbln5Z6VOStzVuaszFmZszJnZc7KnJU5K3NWlqwsWVmy8tlLdG7Ms5kukARNsISR4BPOlrqgJVBCVtasrFlZs7JmZc3KmpUtK1tWtqxsWdmysmVly8qWlS0rW1YeWXlk5ZGVR1YeWXlk5ZGVR1YeWXlkZc/KnpU9K3tW9qzsWdmzsmdlz8o+K/fjSGgJlNATOEESNMESRkJWblm5ZeWWlc8epHECJ0iCJljCSPAJZw9e0BIoIStTVqasTFn57MHeTxgJPuHswQtaAiX0BE6QBE3Iyj0r96zMWfnswa4nUEJP4ARJ0ARLGAk+4ezBC7KyZGXJypKVzx7k4wRNsISR4BPOHrygJVBCT+CErKxZWbOyZmXNypaVLStbVrasbFnZsrJlZcvKlpUtK4+sPLLyyMojK4+sPLLyyMojK4+sPLKyZ2XPyp6VPSt7Vvas7FnZs7JnZZ+V+TgSWgIl9AROkARNsISRkJVbVm5ZuWXllpVbVm5ZuWXllpVbVm5ZmbIyZWXKypSVKStTVqasTFmZsjJl5Z6Ve1buWbln5Z6Ve1buWbln5Z6Ve1bmrMxZmbMyZ2XOypyVOStzVuaszFlZsrJkZcnKkpUlK2cPcvYgZw9y9CCd4BOiBwNaAiX0BE6QBE2whKysWdmysmVly8qWlS0rW1a2rGxZ2bKyZeWRlUdWHll5ZOWRlUdWHll5ZOWRlUdW9qzsWdmzsmdlz8qelT0re1b2rOyzshxHQkughJ7ACZKgCZYwErJyy8otK7es3LJyy8otK7es3LJyy8otK1NWpqxMWZmyMmVlysqUlSkrU1amrNyzcs/KPSv3rNyzcs/KPSv3rNyzcs/KnJU5K3NW5qzMWZmzMmdlzsqclTkrS1aWrCxZWbKyZGXJypKVJStnD0r2oGQPSvagZA9K9qBkD0r2oGQPSvagZA9K9qBkD0r2oGQPSvagZA9K9qBkD0r2oGQPSvagZA9K9qBkD0r2oGQPSvSgnqAJljASfEL0YEBLoISewAlZ2bOyZ2XPynEV+Dg10rgMDGgJlNATOEESNMESRkJWblm5ZeWWlVtWblm5ZeWWlVtWblm5ZWXKymcPipxACT2BEyRBEyxhJPiEswcvyMo9K/es3LPy2YOiJ2iCJYwEn3D24AUtgRJ6AidkZc7KnJU5K589KI8LcD178IKWcF7KtxN6AidIgiZYwkjwCWcPXtASsrJmZc3KmpXPHlQ+wRJGgk84e/CClkAJPYETJCErW1a2rGxZ+exBPbfO2YMXUEJP4ARJ0ARLGAk+wbOyZ2XPyp6VPSt7Vvas7FnZs7LPynYcCS2BEnoCJ0iCJljCSMjKLSu3rNyycsvKLSu3rNyycsvKLSu3rExZmbIyZWXKypSVKStTVqasTFmZsnLPyj0r96zcs3LPyj0r96zcs3LPyj0rc1bmrMxZmbMyZ2XOypyVOStzVuasLFlZsrJkZcnKkpUlK0tWlqwsWVmysmZlzcqalTUra1bWrKxZWbOyZmXNypaVLStbVrasHD1oJ0iCJljCSPAJ0YMBLYESekJWHll5ZOWRlUdWHlnZs7JnZc/KnpU9K3tW9qzsWdmzss/K4zgSWgIl9AROkARNsISRkJVbVm5ZuWXllpVbVm5ZuWXllpVbVm5ZmbIyZWXKypSVKStTVqasTFmZsjJl5Z6Ve1buWbln5Z6Ve1buWbln5Z6Ve1bmrMxZmbMyZ2XOypyVOStzVuaszFlZsrJkZcnKkpUlK0tWlqwsWVmysmRlzcqalTUra1bWrKxZWbOyZmXNypqVLStbVrasbFk5e3BkD47swZE9OLIHR/bgyB4c2YMje3BkD47swZE9OLIHR/bgyB4c2YMje3BkD47swZE9OLIHR/bgyB4c2YMje3BkD3r2oGcPevagZw969qBnD3r2oGcPevagZw969qBnD3r2oGcPevagZw969qBnD3r2oGcPevagZw969qBnD3r2oGcPevagZw969qBnD3r2oGcPevagZw969qBnD3r2oGcPevagZw/62YN2nNASKKEncIIkaIIljASfIFlZsrJkZcnKZw9aO0ESNMESRoJPOHvwgpZACT0hK2tW1qysWVmzsmZly8qWlS0rW1a2rGxZ2bKyZWXLypaVR1YeWXlk5ZGVR1YeWXlk5ZGVR1YeWdmzsmdlz8qelT0re1b2rOxZ2bOyz8rtOI6iVkRFvYiLpEiLrGgUlaOVo5WjlePsSJMgLpKi0zGCrGgUedLZmJNaERX1Ii6SonJQOagcVI5ejl6OXo5ejl6OXo5ejl6OXo5eDi4Hl4PLweXgcnA5uBxcDi4Hl0PKIeWQckg5pBxSDimHlEPKIeXQcmg5tBxaDi2HlkPLoeXQcmg5rBxWDiuHlcPKYeWwclg5rBxWjlGOUY5RjlGOUY5RjlGOUY5RjlEOL4eXw8vh5fByeDm8HF4OL4enox1HUSuiol7ERVKkRVY0isrRytHK0crRytHK0cpRfd6qz1v1eas+b9Xnrfq8VZ+36vNWfd6qz1v1eas+b9Xnrfq8VZ+36vNWfd6qz1v1eas+b9Xnrfq8VZ+36vNWfd6qz1v1eas+b9Xnrfq8VZ+36vNWfd6qz1v1eas+b9Xnrfq8VZ+36vNWfd6qz1v1eas+b9Xnrfq8VZ+36vNWfd6qz1v1eas+b9Xnrfq8VZ+36vNWfd6qz1v1eas+b9Xnrfq8VZ+36vNWfd6qz1v1eas+b9Xnrfq8VZ+36vNWfd6qz1v1eas+b9Xnrfq8VZ+36vNWfd6qz1v1eas+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6n6nOqPqfqc6o+p+pzqj6PAUTjCGpFVNSLuEiKtMiKRpEneTm8HF4OL4eXw8vh5fByeDk8HTGoaFIroqJexEVSpEVWNIrK0crRytHK0crRytHK0crRytHK0cpB5aByUDmoHFQOKgeVg8pB5aBy9HL0cvRy9HL0cvRy9HL0cvRy9HJwObgcXA4uB5eDy8Hl4HJwObgcUg4ph5RDyiHlkHJIOaQcUg4ph5ZDy6Hl0HJoObQcWg4th5ZDy2HlOPt8tCAq6kVcJEVaZEWjyJOizy8qxyjHKMcoxyjHKMcoxyjHKIeXw8vh5fByeDm8HF4OL4eXw9MRA5cmtSIq6kVcJEVaZEWjqBytHK0crRytHK0crRytHK0crRytHFQOKgeVg8pB5aByUDmoHFQOKkcvRy9HL0cvRy9HL0cvRy9HL0cvB5eDy8Hl4HJwObgc0ecSZEWj6HScx6gY6jSpFVFRL+IiKdIiKxpF5dByaDm0HFoOLYeWQ8uh5dByaDmsHFYOK4eVw8ph5bByWDmsHFaOUY5RjlGOUY5RjlGOUY5RjlGOUQ4vh5fDy+Hl8HJ4ObwcXg4vh6cjBkdNakVU1Iu4SIq0yIpGUTlaOVo5WjlaOVo5WjlaOVo5WjlaOagcVA4qB5WDykHloHJQOagcVI5ejl6OXo5ejl6OXo5ejl6OXo5eDi4Hl4PLweXgcnA5uBxcDi5H9blUn0v1uVSfS/W5VJ9L9blUn0v1uVSfS/W5VJ9L9blUn0v1uVSfS/W5VJ9L9blUn0v1uVSfS/W5VJ9L9blUn0v1uVSfS/W5VJ9L9blUn0v1uVSfS/W5VJ9L9blUn0v1uVSfS/W5VJ9L9blUn0v1uVSfS/W5VJ9L9blUn0v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blWn2v1uVafa/W5Vp9r9blVn1v1uVWfW/W5VZ9b9blVn1v1uVWfW/W5VZ9b9blVn1v1uVWfW/W5VZ9b9blVn1v1uVWfW/W5VZ9b9blVn1v1uVWfW/W5VZ9b9blVn1v1uVWfW/W5VZ9b9blVn1v1uVWfW/W5VZ9b9XkMB/MW1Iu4SIq0yIpGkSedfT6pFZVDyiHlkHKcfe4UZEWjyJPOPp/UiqioF3GRFJVDy6Hl0HJYOawcVg4rh5XDymHlsHJYOawcoxyjHKMcoxyjHKMcoxyjHKMcoxxeDi+Hl8PL4eXwcng5vBxeDk9HDCSb1IqoqBdxkRRpkRWNonK0crRytHK0crRytHK0cpx97ho0ijzp7HMfQa2IinoRF0mRFlnRKPKkXo5ejl6OXo5ejl6OXo5ejl6OXg4uB5eDy8Hl4HJwObgcXA4uB5dDyiHlkHJIOaQcUg4ph5RDyiHl0HJoObQcWg4th5ZDy6Hl0HJoOawcVg4rh5XDymHlsHJYOawcVo5RjlGOUY5RjlGOUY5RjlGOUY5RDi+Hl8PL4eXwcng5vBxeDi+HpyMGq01qRVTUi7hIirTIikZROVo5WjlaOVo5WjlaOVo5WjlaOVo5qs+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq8+9+tyrz7363KvPvfrcq889+5yO7HM6ss/pyD6nI/ucjuxzOrLP6cg+pyP7nI7sczqOcrRytHK0crRytHK0crRytHK0crRyUDmoHFQOKgeVg8pB5aByUDmoHL0cvRy9HL0cvRy9HL0cvRy9HL0cXA4uB5eDy8Hl4HJwObgcXA4uh5RDyiHlkHJIOaQcUg4ph5RDyqHl0HJoObQcWg4th5ZDy6Hl0HJYOawcVg4rh5XDymHlsHJYOawcoxyjHKMcoxyjHKMcoxyjHKMcMfPN0U48Gz2xAQnYgQwUoAINOIBli6FxbkGtiIp6ERdJkRZZ0SjypFaOVo5WjlaOVo5WjlaOVo5WjlYOKgeVg8pB5aByUDmoHFQOKgeVo5ejl6OXo5ejl6OXo5ejl6OXo5eDy8Hl4HJwObgcXA4uB5eDy8HlkHJIOmJg0JxlKPY/Cow9jQMZKEAFGnAAvTAm2ZrYgASEjWFj2Bg2ho1hY9gENoFNYBPYBDaBTWAT2AQ2gU1hU9gUNoVNYVPYFDaFTWFT2Aw2g81gM9gMNoPNYDPYDDaDbcA2YBuwDdgGbAO2mO7riN0sZvyaOIBeeKXfhQ142q7dM9JvIgMFeNpa7L+RfhNPW5NAT4yBRIkNSMAOZKAAFWjAAYStwdZgi5nDmgZ2IAMFqEADhm0EemHMJDbxtFELJGAHMlCACjxtMbNTDDJK9MJIjYlhiyWLifkmdmAsugdGsXMbx9ChR9gGnv+sU2AHMlCACjTgWbeHLULhwgiFiQ0YtliGCIWJp+2cNIViIFGiAg04gF4YocAc2IAE7MCwxeqLUJgYtljICIWJA+iFEQoS4giFiQTsQAYK8LRJLE6EwsQB9MIIBYmFjFCYSMD4bbH3RShMFKAXRs9L/IrobomdIFp6/u25ZBoLGS09cQA9McYMJZ5Ldr4pTzFqKLEDGShABYZtBA6gF0ZLTwybBxKwA0+bxZJdUwJeqMDTZhR42uyaU++0ne8DUYwjSmxAAnYgA0/bCEW09EQDDqAXRktPbEACdiADYeuwddg6bNHzI35x9PzEDmSgALUwGnJcEwsaMBSxCRWLrlh0xaJHi4xYUdEiExkoQAUacAC9MFpkYgPCNmAbsA3YBmwDtgFbHCGHBkYFC4wKsctF40w04AB6YgzCSWxAAnYgAwWoQAMOIGwNtgZbg63B1mBrsDXYGmwNtgYbwUawEWwEG8FGsBFsBBvBRrB12DpsHbYOW4etw9Zh67B12DpsDBvDxrAxbAwbw8awMWwMG8MmsAlsApvAJrAJbAKbwCawCWwKm8KmsClsCpvCprApbAqbwmawGWwGm8FmsBlsBpvBZrAZbAO2AduAbcA2YBuwDdgGbAO2AZvD5rA5bA6bw4YsEWSJIEsEWSLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLBnIkoEsGciSgSwZyJKBLIkRQ+0cTEgxZCiRgOfieA9koAAVaMAB9MJoyIkNSEDYDLZoyHjcEiOIEg04gF4YDTnxYaN4cBfjiBI7kIFyIgUq0IDjxFiy+BDAhfEpgIlh40ACdiADwyaBUVcDPTHGECU2YNQdgVHXA8+67QgUoAINeNrizn8MJpoYHweY2ICnLb7JEcOIKG7AxzgiijvpMZCI4p55jCQiuv7ZAHphfCVgYgMSsANPG1GgAE9b3BKPMUWJA+iF8fWOiQ142nqsh+sbHhcyUICnrcfiXN/yuHAAT1vcPvfrix4XNmDYODBssQzXlz0uFKACDTiAYTv3ar++8nFhAxKwAxkoQAUacABhU9gUNoVNYYsvgPTYJ+MbIBMVGNst9qj4EshEL4yvgUxsQAKeNo71G18FmShABRpwAL0wvhAysQEJCNuAbcA2YItQ4FjICIWJDUjADmSgABVowAFMW49hSIkNSMAOZKAAFWjAAYStwdZga7A12BpsDbYGW4OtwdZgI9gINoKNYCPYCDaCjWAj2Ai2DluHrcPWYeuwddg6bB22DluHjWFj2Bg2ho1hY9gYNoaNYWPYBDaBTWAT2AQ2gU1gE9gENoFNYVPYFDaFTWFT2BQ2hU1hU9gMNoPNYDPYDDaDzWAz2Aw2g23ANmAbsA3YBmwDtgHbgG3ANmBz2Bw2h81hc9gcNofNYXPYkCXtyhIObEACdiADBRiKI3AAvfAKkAsbkIAdyEABKhC2BluDjWAj2Ag2go1gI9gINoKNYCPYOmwdtg5bh63D1mHrsHXYOmwdNoaNYWPYGDaGjWFj2Bg2ho1hE9gENoFNYBPYBDaBTWAT2AQ2hU1hU9gUNoVNYVPYFDaFTWEz2Aw2g81gM9gMNoPNYDPYDLYB24BtwDZgG7AN2AZsA7YB24DNYXPYHDaHzWFz2Bw2h81h87LRcQAbkIAdyEABKtCAAwjblSUW2IAEDNsIZKAAFWjAATxtErbIkokNGDYP7EAGClCBBjxt51cr+vX5wQsjSyY2IAE7kIECVKABYeuwMWwMW2SJUGAHMlCACjRg2CTQCyNLJoZNAwnYgQyMurFhrw8Sxha6Pkl4IQHPChpbKPJhogDP5T0/S9GvzxNOHEAvjHzQ+EGRDxMJ2IFRN1Zf9Pw5NKZfHyOc2ICxvKG4Pkl4IQMFqEADDqAXRs9rrN/o+YkE7EAGClCBBhxAT7w+WjixAQnYgQwUYNg00Aujuyc2IAE7kIECRN3o7okDCBvBRrARbAQbwUawEWwEG8FGsHXYOmwdtg5bh63D1mHrsHXYOmwMG8PGsDFsDBvDxrAxbAwbwyawCWwCm8AmsAlsApvAJrAJbAqbwqawKWwKm8KmsClsCpvCZrAZbAabwWawGWwGm8FmsBlsA7YB24BtwDZgG7AN2AZsA7YBm8PmsDlsDpvD5rA5bA6bw+Zl4+MANiABO5CBAlSgAQcQNmQJI0sYWcLIEkaWMLKEkSWMLGFkCSNLGFnCyBJGljCyhJEljCxhZAkjSxhZwsgSRpYwsoSRJYwsYWQJI0sYWcLIEkaWMLKEkSWMLGFkCSNLGFnCyBJGljCyhJEljCxhZAkjSxhZwsgSRpYwsoSRJYwsYWQJI0sYWcLIEkaWMLKEkSWMLGFkCSNLGFnCyBJGljCyhJEljCxhZAkjSxhZwsgSRpYwsoSRJYwsYWQJI0sYWcLIEkaWMLKEkSWMLGFkCSNLGFnCyBJGljCyhJEljCxhZAkjSwRZIsgSQZYIskSQJYIsEWSJIEsEWSLIErmyZAQ2IAE7kIECVKABB9ALCTaCjWAj2Ag2go1gI9gINoLtChALJGAHMlCACjTgAHrhFSAXwsawMWwMG8PGsDFsDBvDJrAJbAKbwCawCWwCm8AmsAlsCpvCprApbAqbwqawKWwKm8JmsBlsBpvBZrAZbAabwWawGWwDtgHbgG3ANmAbsA3YBmwDtgGbw+awOWwOm8PmsDlsDpvD5mXT4wA2IAE7kIECVKABBxC2BluDrcHWYGuwNdgabA22BluDjWAj2Ag2go1gI9gINoKNYCPYOmzIEkWWKLJEkSWKLNErSzzwtJ2vePQYgZnohZElExuQgB3IQAEqEDaGjWET2AQ2gS2y5HwPpccIzEQBKtCAAxi28wZFjMCkcWEDErADGShABRpwAL3QYDPYDDaDzWAz2Aw2g81gM9gGbAO2AduAbcAWqXFOkNtjVCUZBzZgVJDADmSgABVowFje2PsiHwJjVGViA542PwI7kIGn7RxR02NUZaIBT9s551KPUZUTIx8mNmDYemDU5UAFGnAAo+554hLjJ+kcGtNj/CSdL9P3GD/5uIcT2E+MJTuToB8hPpMgUYEGHCfGkp1JMPFMgsQGDJsEhiIWp4ciFqeHItbv2f69xeKc7f+4yRPohWf7JzYgATuQgaetxTKc7Z84cueKkZITo+cnNiABO5CBAlSgAWET2DR+UKwSbUACxg+KFaUMFKACDTiAXmgHsAEJCJvBdvZ8p1jes+cTDTiAXnj2fOJpo1jrZ88ndiADwxb771CgAcMWSzYqYWKkZGIDErADGShABRpwAMs2jgPYgATsQAYKUIEGHEDYGmwNtgZbg63B1mBrsDXYGmwNNoKNYCPYCDaCjWAj2Ag2go1g67B12DpsHbYIkPMd6B4jJRPPvaRf/4EBB9ALI0B6D2xAAnYgAwWoQAOGjQO98Dp/kMA4C4r/9rrquDDqXv+BAg04gF4YqTGxAeNXWGAHMjBsI1CBBgybBnphpMbEepQxrquOCzuQgQJUoAEHsB6cDDw4uQZuxuOfa+DmxPgVseUjHyYacAC90A9gA57rjFtgBzLwtJ0DvnpMB5dowNMWTydjOOeFMZwzsR5XXcM5J3YgAwWoQAMOoBe2Axi/ogcyUIAKjF/BgQPohXQAY1yxBRKwAxkoQAUacAC98JoN4cL4FfGDoucnClCBBhzA81fEI8kYrZnYgAQ8bfEANEZrJgrwtEmsh+j5iQMYtrNFYrRmjz01Rmv28239HqM1EzuQgQJU4GmLx5cxWjPRCyMJJjYgATuQgQJUIGwKm8JmsBlscf4Qz0JjtGYiA8MWayfOHyYacAC9MM4fJp62uEqK0ZqJHcjA03Z+PrTHaM1EA562uPqKMZyPM6QTIx8mNiABO5CBAlSgAcMW+0Pkw4kcYzj7+dUpjjGciQTswNN2ni5yjOFMVKABB9ALz3xIbMDTdk4TwDGGMzFsPVCACjTgKIzXK46oQKHgQAJ2IAMFGIpYO3GpMXEAvTAuNSY24Gnz+G0RIBMZKMDT5rG8ESATB/C0efy2CJCJDRg2CQybBoYtFicCZKICDTiAXngN7A7qRVwkRVpkSWcH83lpxzFyMtELzw5ObEACdiADBahA2Aw2g23ANmAbsA3YBmwDtgHbgG3ANmBz2Bw2h81hc9gcNofNYXPYvGwxcjKxAQnYgQwUoAINOICwNdgabA22BluDrcHWYGuwNdgabAQbwUawEWwEG8FGsBFsBBvB1mHrsHXYOmwdtg5bh63D1mHrsDFsDBvDxrAxbAwbw8awMWwMm8AmsAlsApvAJrAJbAKbwCawKWwKm8KmsClsCpvChixpyJKGLGnIkoYsaciShixpyJKGLGnIkoYsaciShixpyJKGLGnIkoYsaciShixpyJKGLGnIkoYsaciShixpyJKGLGnIkoYsaciShixpyJKGLCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6cgSRpYwsoSRJYwsYWQJI0sYWcLIEkaWMLKEkSWMLGFkCSNLGFnCyBJGljCyhJEljCxhZAlfjU6BDUjAuFkbxEVSpEVWNIo86XrlIqgVUVE5uBxcDi4Hl4PLweWQclxtzYEE7MBYhRoowFiFHmjAAfTCq60vbEACdiADBQibwqawKWzR1i02WLT1RAJ2IAMFeNrOx8scoycTBzAeS510jVcIakVU1Iu4KCrG7hJNes6jwDEWklus72jSiR3IwFjS2ArRpBMNOICeOMdCBrWicFlgBzIwXB6oQAOervPhLcdIyInRoufsDBwjIRMJGA+egrhIirTIikZSHNLpwnNJiQPPJY1dOsY1JhpwAGNJ4wdGT09sQAJ2YNyqDpIiLYo7/kGjyJOuhwtBrYiKQjICGSjAURgNS7Hyo2EnxpOQIC6SonON9Ng00a0TB/BcI9fqjW6deKquCtGtE8+FvZY7uvX6+dGtPdZTdOv5UItjqGLiAHphdOvEBiRgB542juWNbuXYlaJbOZY3DrccCxmHW46FjMPtRAJ2IAMFqIXRqBw/Mxp1IgE7kIEC1MQYPMjnW4gcgwcTGSjA+GcjMNakB8bOEORJV8cFtSIq6kVcJEVaZEXlaOWgclA5qBxUDioHlYPKQeWgclA5ejl6OeJM+XypkvU6Uw6yolHkSddZclAroqJexEVSVA4uB5eDyyHlkHJIOaQcUg4ph5RDyiHlkHJEr0mshei1iQI8C0nsLNFr54NIjqF8LLHfRFdJ7DfRKeeLixwD8Vjjv43j2kQvjP7R2GGjfyYSsAMZKEAFGjBsHOiF0WATT5vFb4tWslicaKWJZ127/lsDDqAnxvC865/F8LxEAnYgAwWowAGMRT8p+u6iVkRFvYiLorgEKtAKo80mxuLFP4umioeCMe4uUYEGHEAvjNaaGCtjBBKwA8PmgQJU4GmL54MxBC/RC6MDJzYgATuQgQJUIGwMG8MmsAlsApvAFv0YDzFjNF6iAqNubOg4AsZzxxhWlxiLE1soOm3EFoqj2oVxVJsYFWKtx1Ft4rk48YQxBsVxPCqMwWvsoYg+meiF0ScTz7rxWDEGryV2IAMFqMCoey5kDFNLbMCoa4EdyEABKtCAA+iFsdufY0w5BpklDqAXRjNMbMBYMg/sQAYKUIEGfNgkLutikNnEs0USG5BObIFyIgXqiT3QgAPohXwAG5CA/UQOZKAAwyaBBhzAsMXakQPYgATsQAYKUIFhi3V2HqAkroBi4JjEVUwMHEsUoALPJYvLnBgiltiABOxABgpQgeeSxSVRDBFL9MJxABswFLHOBgOjWOz2HosTe6qHONaDhzjWgxvwFEeBs5uCYkzXpFZERb2Ii6RIi04JHYED6IXnkSexAQnYgQwUYNQ9t2cM25K4NIthW+cQJY5RW5O4SIq0yIqiYg/0wuiqiQ1IwA48q8YVXQzNkrhgi6FZiXFNEkRFvYiLpEiLYp1a4AB6YXTOxAYkYKy9ERgVPPCsEHRePE1qRec/j38SXXMRF0mRFlnRKYlLtBhfNTHaaGIHnv++xzaM1pg4gGeF+BnRGRe1IirqRVx0LmZcFcZoqUQDDqAX+gFsQAJ2IANhc9ii7+LCM0ZLJfpEidFScl6DSoyWSgzbCAybB56282JSYrRUogJP27nfSIyWSjxt5yWmxGgp4RCfDajxr87+m9SLuEiKtCgq6onRehwLHb3HsaTRfBMFGElxBBpwAL0wGnBixE+Io9XOqwiJoU0i8QPjADbRC6MBJzYgATuQgQIMW6y4aMOJAxi2WJ3RhhMbkIBhi3UWB7CJAjxXb5Q9j1+TRtFDpbFUZ79OakVU1Iu4KCSxjaJhJxpwFMYxbmIsZuyEcTSbGBVie0bLThzAc0mjwNmyk1oRFfUiLpIiLbKiUVQOL4eXw8vh5fByeDm8HF4OL4enI8ZDTWpFccg5AjuQgXHUoUAFGvBcZbFxYzTUxOjQSxGHyIkE7EAGhm0EKjBsHnjaLJYsuvccLyoxGiqxASNWYyGjpycy8GG7ap0tPcmKRpEnne08KSr2wHNJLX52dPN5ASkxtinRC6ObJ8aSxs+Obp7YgQwU4Lmo8fuimS1WSzTzuP7WC6OZRyzj2bbzLx//3uPnx+dto2Z83vaiVhTHTg3sQAYKUIEGHEAvjCPoxAaEzWAz2Ay2aN0RCxmtO3EAvTAOtxMbsOc6iA/dXiRF5xoKU3zo9qJRFMVjv4xD7MQGJGAHMvD8KR57URxiJ8ZPia0Zh9iJnkj5bWuh/La1UH7bWii/bS2U37YWym9bC+W3rYXy29ZC+W1rofy2tVArRytHK0crRytHK0crRytHK0crB5UjevW8FJcYbZTYgedKi40So40SFWjAc6WdF/MSo43kvFaX+S3YKBazvE8kYNgkkIECVKABB9ALo7snNiABYWPYGLbrC7FHoAEH0AuvL8Re2IAE7EAGChA2gS1Or2Nnp+v0OvA6v76wAQnYgQwUoAINGDYL9MJIiYkdGBWiG87O12t5z85P9MI4ak88D3fX5o7j9sQOZKAAFWjAAfTCOH5PhM1hc9gcNofNYYvD+BF7dRzHJ4bt3KtjBFFiA4ZNAjuQgQJUoAEH0Atb2DSwAQnYgWEbgQJUoAEH8LSd9xYkRhAlNiABO5CBcX5vgQo04ACGLcT9ADbgaTuv1CVGECmF4syHRAEq0IAD6IVnPiQ2IAFhY9gYNoaNYWPYGDaBTWAT2AQ2gU1gE9gENoFNYFPYFDaFTWFT2BQ2hU1hU9gUNoPNYDPYDDaDzWAz2Aw2g81gG7AN2AZsA7YB24BtwDZgG7AN2Bw2h81hc9gcNofNYXPYHLbIkvNej8QIosSwSSABO5CBYRuBCjTgAHphZMnEBiRg2DyQgZrHgBg2lDiAcV15pmcMG0qMK8seSMAOjIvL+PERIBMVeP6guMURM70lemEEyMQGJGAHMlCACoTtjIo4YY+hSJOo6Dydv/47LpKiqKiBBhxAL4yQmNiAsfyxZiMkJjLwlMUGOzNikhWNIk8682FSK6KiXsRF5dByaDm0HFoOK4eVw8ph5bByWDmsHBEH/cIB9MLrHl7smNdNvAvjIu76DzqQgZKXYzFvW2LcJTkCB/C0xd2wGKuU2IDnWflFvYiLpEiLbFKMR9LzAb/E2CON+2sx9kjj/lqMPUpUoAFjSTXQC6O5JzYgAU9b3A2LwUeJAlSgAQfwtMVdq5iFLbEBCRg2CWSgAMNmgact7njEaKVEL4w+n9iABOxABgpQgbB12DpsDBvDxrAxbAwbw8awMWwMG8MmsAlsApvAJrAJbAKbwCawCWwKm8KmsClsCpvCprApbAqbwmawGWwGm8FmsBlsBpvBZrAZbAO2AduAbcA2YBuwDdgiGeJOdUzIlhi2aN5IhokNSMCwxb4eJwoTBahAAw6gJ8aEbIlh00AChsICBahAA4ZiBHphBMjEBqTMqBhNlchAASrQgAPohREgE/u8qRYjqCZJ0XnLLX543B28aBTF8p+HAL1C4sIGJGAHMvA0UZAWWVHcyj0CvTASYuJDFUeYGGc1qRdxkRRpkRWNIk86g2FSOaQcUg4ph5RDyiHlkHJIObQcWo4Ig2vdRxhMZGDc/I5NF2EwMW5/x0aJMJjohREGFjtrhMFEAnYgAwWoQAOGLXbs67FB4PXc4MIGDFts9+vRwYUMFKACT9uI7R1hMNELzzCY1IqoqBdxkRRpkRWNIp8Ug7omtSIq6kVcJEVaZEWjKH7IuW1jXJeeo30kBnYlErADGShABRpwAL2QYCPYCDaCLc4i4hQ7BoIlKtCAA+iFERBxvzIGgiUSsAMZKEAFGnAAvZBhY9gYNoaNYWPYGDaGjWFj2AQ2gU1gE9gEtjhfiPu2MeQrrvdierVJ8Y8skIECVKABBzCe3sSuZQewAQl4RlrcbovZ1RIFGA+KYmnNgAMYtthdxgFsQAKGLXaMEXU10IAD6IUedUdg1I0Vdfa6tWgmj6NZLK/H4SyWzON4FmJXoAEH8LSdw3MkBqglNiABw2aBofDAOJIdgXEoa4GnIm5BxKg0O9+FkJg8LbEBCdiBDBRg2GIZmgFDEYtDB7ABT0WPhYwzgIkMFKACDTiAXhiPCSc2IGwdth62WCVxHjBRgQYcQC/ksMUvjlOBiQTswLCNQAEq8LTFNehAmw+0+UCbD7T5QJsPtPlAm8cQt0QFGhA2gU1hU9gUNoVNYVPYFDaFTWFT2Aw2g81gM9gMNoPNYDPYDDaDbcA2YBuwDdgGbAO2AduAbcA2YHPYHDaHLVIjbi7E7GqJ517C13+gQAMO4LlPxrCcGImX2IAE7EAGClCBYdPAAYzD6rlXx9A74ws7kIECjLoj0IAD6IXXuAIObEACdiADBahAK4x8iMFEMSwvkYAdyEABxuXH2aYxLM9iXFGMy7MYVxQD8xIZeFaIUUExNi8xrmpiyeIqYKIXxnVA3DOJwXmJBOxABgpQgWGLTRjXAxO9MK4IJjYgAWMMUmwh1VoPakCsnTj6xz2eGLuX2IAE7MD4FaGIo/9EBRrwtMUle4zzmxhH/4mnLa7IY6hfYgeethjkFKP9EhUYttjycU4Qg2xitJ/FFXmM9rO4DI/RfokEjLrx26KPJxpwAKPu47dpjOCLnUtjBF8iAwVohTH8Z2IDEjA2IQUyUIAKNOAAemG06cQGjJXqgQJUoAHPH39eTWsM3psYbTqxAXOooF5D+iYyUIAKNOAAemEMHpiYQ0v1GtI38fwVdqECDTiA8StiPUTzTmxAAnYgA2Mg6IUKNOAAemEME5jYgATsQAbGr+iBA+iF0bwT41dwIAE7kIExaji2cQwemGjAAfTCuMM/sQEJGNtCAhVowAGMX6EnRptObEACdiADBajAsMUOE8070RNjwF9i2EYgATuQgbHOJFCBBhxAL2wHsAEJ2IFRtwXGr/DAAfTCOHU/7xJoDO6z87GJxuC+xA5koAAVaMABjLtR5w4Tk5rZiIWMPj5H5msM5rNz9JnGYL6JceI9sQGjQqz16y7chQwUoAINOIBey3CNkL+wAQnYgQzEr4g+nmiF1w242PLXHbhY63G4ndiBDDx/hcdmiYPwRAOev8JjG0cfXxh9PLEBCdiBDAxbLG8chCcaMGyxNeMgfGEchCc2IAE7kIFhi/0hunuiAcMWe0l094XR3RMbkIAdyMCwxb4T3T3RgGGLLXTdizvXL10341pg3I2jQAJ2IAPjjhwHxi05CYx7cho4gF7YDmDYRmDYPDBGmMaSnUf0RAEqMH6bBQ6gF0bPT4z3h8IWJ94TO5CBAlSgAQfQC3s8V4812TuQgQKMXxFr8jyiJw6gF17P8C9sQAJ2IAOjbg8cQC+UqBubUBqQgB3IwKgbmzsexrfYmvE0fiIBO5CBMt++1GvqsIkGHEAvvN7JvLABCdiBsX5jy5sBB9ALR/yK2IQjtlDsiEOBBjwrUOx9Z8dOjJvmE89fHIekGKA3KFZ13COnWH1xk/xaD3GXfOIAemIM0EtswKgrgQJUoAHHfP9Yr8m8Lox3nic2IAE7kIECVOBZ9xx1o9e0XRMb8NwfzltpGoPuEuNXeKAAFXj+ivPmlsagu0QvPM+rR5z3xaC7RAJ2IANPW4+1E1040YAD6IXRhRMbkIBRN1bJNdlH/IrorB6/ODprYgfGksWKitEwE2PJrgoGHMBzyTjWQ3ThxAYkYAcyUICn7bxRozFkLnEAvTAGx0xsQKpfHGNhOFZ1dOFEAw5g1D1bJAbHJTYgAc99Mnroml5rogAVaMAB9MJ4D3tirJ0LGShABcaviM0dHTvRE2MYXOLZAZG010RaEzuQgQJUoAFHYYw6b5E2MSqsmBeWhXVhW3gs7OBzRy9uCy9eXry8eHnxyvX3scwiC+vCtvBY2MF6LNwWpoX7wotXF68uXl28unh18dritcVri9cWry1eW7y2eG3x2uK1xTsW71i8Y/GOxTsW71i8Y/GOxTsW71i8vnh98fri9cXri9cXry9eX7y+eB3eGEZW3BamhfvCvLAsrAvbwmPhxdsWb1u8bfG2xdsWb1u8Z395nLzGgKzEAfTCs7cSG5CAHchAAcLGsDFsDJvAJrAJbAKbwCawxVtecY4eA7ISB9AL4+2viQ1IwA5koABhU9gUNoXNYDPYDDaDzWAz2Aw2g81gM9gGbAO2AduAbcA2YBuwDdgGbAM2h81hc9gcNofNYXPYHDaHzcsWA7ISG5CAHchAASrQgAMIW4OtwdZga7A12BpsDbYGW4OtwUawEWwEG8FGsBFsBBvBRrARbB22DluHrcPWYeuwddg6bB22DhvDxrAxbAwbw8awMWwMG8PGsAlsApvAJrAJbAIbskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyJIY4uVx1y2GeHlcisQQr0QFGnAAvTCyZGIDErADYRPYBDaBTWAT2BQ2hS2yJG5oxdiwRAYKUIEGDJsGemFkycTTFtdCMTYssQMZKEAFGvC0xZ32GBvmce4ZY8MSG5CAHchAASrQgAMIm8PmsDlsDpvD5rA5bA6bw+ZlixFjiQ1IwA5koAAVaMABhK3B1mBrsDXYGmwNtgZbg63B1mAj2Ag2go1gI9gINoKNYCPYCLYOW4etw9Zh67B12DpsHbYOW4eNYWPYGDaGjWFj2Bg2ho1hY9gENoFNYBPYBDaBTWAT2AQ2gU1hU9gUNoVNYVPYFDaFTWFT2Aw2g81gM9gMNoPNYDPYDDZkyUCWDGTJQJYMZMlAlgxkyUCWDGTJQJYMZMlAlgxkyUCWDGTJQJYMZMlAlgxkyUCWDGSJI0scWeLIEkeWOLLEkSWOLHFkiSNLHFniyBJHljiyxJEljixxZIkjSxxZ4sgSR5Y4ssSRJY4scWSJI0scWeLIEkeWOLLEkSWOLHFkiSNLHFniyBJHljiyxJEljixxZIkjSxxZ4sgSR5Y4ssSRJY4scWSJI0scWeLIEkeWOLLEkSWOLHFkiSNLHFniyBJHljiyxJEljixxZIkjSxxZ4sgSR5Y4ssSRJY4scWSJI0scWeLIEkeWOLLEkSWOLHFkiV9ZIoENSMAOZKAAw6aBBhxAL7yy5MIGJGAHMlCAsF1Z4oED6BPtuLJkBDYgATuQgQJU4Gk7x2VZzFGX6IWRJRMbkIAdeNrOh1EWQ+ASFWjAAfTCyJKJDUjADoSNYCPYCDaCjWDrsHXYOmwdtg5bh63D1mHrsHXYGDaGjWFj2Bg2ho1hY9gYNoZNYBPYBDaBTWAT2AQ2gU1gE9gUNoVNYVPYFDaFTWFT2BQ2hc1gM9gMNoPNYDPYDDaDzWAz2AZsA7YB24BtwDZgG7AN2AZsAzaHzWFz2Bw2h81hc9gcNofNyxZD6xIbkIAdyEABKtCAAwhbg63B1mBrsCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrIkBvL5OQrBYiBfIgHD5oEMFOBpO4cTWAzkSxzA08ZhiyyZ2IAE7EAGClCBYRuBA+iFkSUTG5CAHcjA0yax6JElEw142iSWIbIk8JrYb+JpO98JsGtqv4kdyEABKtCAA+iFkSUTYWuwNdgabA22yJLzDQS7ZvqbOIBeGFkysQEJ2IFh00ABKtCAA+iFkSUTG5CAHQhbhy2y5Hz1wWJ4X+IAemFkycQGJGAHxvlkCxSgAg04gF54XeNc2IAE7EDYBDaBTWAT2AQ2hU1hU9gUNoVNYVPYFDaFTWEz2Aw2g81gM9gMNoPNYDPYDLYB24BtwDZgG7AN2AZsA7YB24DNYXPYHDaHzWFz2Bw2h81h87L14wA2IAE7kIECVKABBxC2BluDrcHWYGuwNdgabA22BluDjWAj2Ag2go1gI9gINoKNYCPYOmwdtg5bh63D1mHrsHXYOmwdNoaNYWPYGDZkSUeWdGRJR5Z0ZElHlnRkSUeWdGRJR5Z0ZElHlnRkSUeWdGRJR5Z0ZElHlnRkSUeWdGRJDHN0u1CBBjxt52s+FsMcJ0aWTIzHPxoYD3rOY2yMV0xsQAJ2IAMFqEADDiBsDpvD5rA5bA6bw+awOWwOm5ctRjEmNiABO5CBAlSgAQcQtgZbg63B1mBrsDXYGmwNtgZbg41gI9gINoKNYCPYCDaCjWAj2DpsHbYOW4etw9Zh67B12DpsHTaGjWFj2Bg2ho1hY9gYNoaNYRPYBDaBTWAT2AQ2gU1gE9gENoVNYVPYFDaFTWFT2BQ2hU1hM9gMNoPNYDPY4lTCLoywGYEGHEAvjCyZ2IAE7EAGChC2AduAbcAWWXK+FGcxzjORgB3IQAGGTQMNOBLliooLO5CBAlSgAc9i50w+Jte84oHXxOIXnot+fu7L5Jpa/MIOPG3ni3km1+ziFyrQgAPohdcU4xc2IAE7EDaCLaLifCPQYmrAxAH0woiKiQ1IwA5koABz5IBdI1EnDmDYzt3zGok6sQEJ2IEMFKAC47eNwAH0woiKiQ1IwA5koBRGo5+vDNo1jnQiA/NJhUk9FzGp5yIm9VzEpJ6LmNRzEZN6LmJSz0VM6rmIST0XMTHYDDaDzWAz2AZsA7YB24BtwDZgG7AN2AZsAzaH7bpmiBV1XTNc2IH1pOIaRzpRgafNYzeKRp/oidc40okNSMAOZGDcyWmBCjRg2C70wkiCiQ1IwA5koABP2/kepl3jSCcOoBdGEkxsQAJ2IAPrntg1IPR8D9OuAaETO5CBAlSgAQfQC6OlJ8LGsDFsDBvDxrAxbAwbwyawRcfG3bprvOdEBcbW9MAB9MI4uJ8vato13nMiAeNOGQUyUICx6CPQgAPo8WWC2PTxakdyW5gW7gvzwrKwLmwLj+Cz82I054Njfxi8sCysC9vCY2EH+7FwW7huZF7DOicy8JJerAvbwmNhL46xncVtYVr4+rEjmBeWhXVhW3gs7OB2LNwWDu85JtFioGcxLywLh/d8/dZisGfxWNjBdCzcFqaF+8K8cOyYsZhxCjDRgJeUgh08PzRycVuYFu4L88Ky8PVjY6N0W3gs7GA+Fm4L08J9YV74qn/2qV2fDWnxG6/vhkzmhWVhXdgWHgs7WI+Fz6SIO+LXaM6JHXhJPVgW1oVt4bGwg6+4mNwWjh9L4briYjIvLAvrwrbwWNjB8SZYcnjPNxYtxncW94V54csbG+iKl8m28FjYwVe8TG4L08J94TNg5EIBKvCSavBY2IvHFS+T28K0cF+YF75+rAfrwrbwWNjBV7xMbgvTwn3hqB+nJuOKkcljYQdfMTK5LRz1z1eSbVwxMjl+1zkln8V4z+LLy8G28OWVYAdfSdJj/VxJMvnyWnBf+PKOYFn48sZvv5Jkcnjj+D6uJLn4ShKO33glyeTwxsF6XEkyObwcvzFeH00OL8dvvBJm8uWN33h9xeji6zNGHL/x+o7R5Msbv/FKpMmXN37jlUiTwyvxW65Eklj+K5EiWMaVSBLLeSXS5LYwLdwX5oVlYV3YFh4LL15bvLZ4bfHa4rXFa4vXFq8tXlu8tnjH4h2LdyzesXjH4h2LdyzesXjH4h31vPEaLzqxAQnYgQy8Kp97jl8JE4nkV8KcU6GZXwkzuS/MC8vCurAtPBZ28JUwkxdvW7xt8bbF2xZvW7xt8bbF2xYvLV5avLR4r+Q555czv5Jnsiw8wFeSnFPIm19JMrkvzAvLwrqwLTwWdvCVJJMvLwXTwn1hXlgW1oVt4bGwg6UeNl/DQCcS8JL2YF5YFtaFbeGxsIOvGJl8/VgNpoX7wrywLKwL28JjYQdfMWKxca8YmRzeeELiV4xYrByr593X2NCJCjTgANbT9Wts6MQGJGAHwjZgu6IjHs74FR2Tx8IOvs5nJreFaeG+MC8sC1/eCJArWCaPhT15HFfgTG4LX/+9Bzv4CorJbWFauC8cy3nOaTaOKyguvhr8vE06jqvBJ/PC139vwbqwLTwWdvB1ajG5LUwL94V54cXbF29fvH3x9sXLi5cXLy9eXry8eHnx8uK9AuG8xziOKxAmO/g6tZjcFqaF+8K8sCysCy9eWbyyeHXx6uLVxauLVxevLl5dvLp4dfHq4rXFa4vXFq8tXlu8tnht8V6nFiP22+vUYrKDr1OLyW1hWrgvzAvLwrpweM/J3cZx5YNHj1z5cPGVD5PbwrRwX5gXloV14Rz2M66hnxNz2M9oVzicE8WNdoXDZFq4L8wLy8K6sC18/VgNdvAVMpPbwrRwX5gXloUVXOMoRruyx+MnXtkzmReWhXVhW3gs7OAreya3hRdvX7x98fbF2xdvX7x98fbFy4uXFy8v3it7zhuWo13Zc35kdLQreybrwrbwWNjBV/ZMbgvTwvG8LlZ/3IqdKMBTGp9lHe2acmfyWNjB15Q7k9vCtHBfmINjv7um3JmsC9vCY2EHX1PuTG4L08KXl4N5YVlYF7aFx8IOvqbcmdwWjmeiF3YgAy+pBOvCtvBY2MHXfDuT28K08PVjY++65tuZLAvrwrbwWNiL6ZpvZ3Jb+PJ6sCysC0f98x7noGtenclR/7z1OOiaV2dyWzjqn29fD7rm1ZnMC8vCurAtPBZ2MB0Lt4UXLy1eWry0eGnx0uKlxUuLty/evnj74u2Lty/evnivebrOd8sHXfN0TR4LO/iap2tyWzgeuFvgVVKCbeGx8FXyzPHrU9DJbWFauC/MC8vCurAtPBZevFeuXMt85UqLXfLKlcmysC5sC4+FHWx15T9o3iu5mBbuC/PCsrAubMX92vXOK+rRr11vMi0cv+u8mh392vUmy8K6sC08FnbwtetNbgvTwou3L96+eK9d6bz6Hf2a2u28EB39ms5t/v21bBx8LVv89mtfmuzga1+a3BamhfvC17JpsCysC19eC768I/jyxnq+jl3nRezo17Hr+i3XPjZ5+Y3X/sOxDNf+M9nB13FpcluYFu4L88KysC58eeN3Xccljt91HZcuvo5Lk9vClzd++zUV3GReWBbWhW3hsbCDr0MQx/q8DjUS6/M6vEjsM9fhRWLfuA4vwXwdXia3hXnhq04PHgtfdc59jK/DRfQXX/F/frVh8BX/kx08e9CC28K0cF/4Wp4RLAvr8t/YwmNhB189GOuHrx6cTAv3hRXroS/roS/r4Yr5i699+HxmMOaUhz3+7bUPT+aFZWFdOFw9al77c4/1fO3Pk2nhvjAvLAvrwlf92F7X/jzZwdf+PLktTAv3hS9vbN9rf56sC9vCY2EHX6dak9vClyu243V6NVkW1oVt4bGwF8/pDCe3hWnhvjAvfHlHsC5sC4+FHXyddk3GNp3TGU7uC2ObytU753OdIVePnM9yhlw9MlkW1oWvPGnBY2EHXz0yuS1MC/eFeWFZWBdevH3x9sXLi5cX73WMu37vNX3p+SxqyHVcmzzwG6/j2sXXcW1yW/j6LT24L8wLX78l1vl1XJtsCy9eWby6eHXxXpkwedl2umw7XbadLttuHvsuXry2uOa0prFsc1rTi3VhWzjqnA+Gh8xpTYPntKYXt4Vj+c/nuEPmtKYX88KysC5sC4+FHTynNb24Lbx4ffH64vXF64vXF6/Dq3P6Ugu+6ozg6996sC08FnbwnJr04rYwLXztw0cwLywL68KG5bmOoZMdfOXA5LYwLdwXXn7jlQ8XxxTbca87BrAl2omxomKK7YleGFNsT2wnxoqMKbYndiADBahAAw6gF8b09xNhizm4LX5FzMEdd9r1+iZ9rMfro/QXeuH1WfoLG5CAHchAASoQNoVNYTPYDDaDzWAz2Aw2g81gM9hiZu54VBATFiY2IAPjvz1T8/p87MQGJGAHMlCACjTgSLy+HnsOrx7X52MnErADGShABRpwAL0wvlJxDq8eMbBsnAOeR4wrS1RgFNPAAfRCOoANSMAOZKAAFQhFzHkfTRaDwxLP+1THhQJUoAGrIQ0NaVwtYmhIQ0MaGtLQkIaGNDSkoSENDWloSENDGhoyRpQlVpbEWLHEAfTCaMiJDYgVpVhR0ZATBQibwqawKWwGm8FmsBlsBpvBds0VGmt94MdfU4FeyLVZ4isVExVoQGzNga3pBxAKx/p1bE3H1nRsTcfWdGxNr60Zg7Wu9IyxWld6jqMiaBwCVKABB7ACLwZpJTYgATsQtgZbg63B1mBrsBFsBBvBRrARbATb1aYt0ICjsDdgBV6Mr0ocwIrXGFyV2IAE7EAGCrACL0ZSJVbgxTiqxAYkYAcyUIAKHJme4zosSiABO7ACb6gAFWjAAax4HXYAG5CAHQjFdaiL/fc61F3YgATsQAYKUIEGHEDYroNldMt1sLyQgB3IQAEq0IAD6Il+HMAGJGDtBDFkacSDrBixlEjADjyXLB6AxWilRAUacAC9MPptYgMSsANhI9gINoKNYCPY4rMx8eAsRjMlxuq7MP7ZEeiF0XoTG5CAsZAtMBaHAg04gF4Y/TaxAQkYdWOzRL9NFKACDTiAXhiHxfPllBGjjBIJ2IEMFKACDRiKs49jRFFiAxKwAxkoQAUacABhG7BFx8YD6RhNlNiBDBSgArGxBjbWwMby3Fh+TaB2Pv70a6q0880Pv6ZKm9iBDJS5n/lxHSQuNOAAemHstBMbkIAdyEDYOmwdtg5bh+2aAzp+2zUHdPzia+b4C7V+0DVz/IUD6IXXzPE9sAEJGCuKAxkoQNgENoFNYLtmjr8Qm0WxWRSbRbFZrpnjL4Ttmi6+/fcffnuU+q/fYnWfd6djZQdwgiRogiWcq/i8jx0r+ISIkvOudQRJQFR+xGmESEBUfgRWHLsDovJj+0SkBJyVz3GZESfxkeAj4ax8PtyJIAnoCWfl+GCwJJyV4wvBljASovI53/WR0BKi8uPnRGQEcEJUfvyuCIuAqHx+8Gok+ITIi5jepiVQQlSOV44TJCFORePFnoQ4DY0BixMiG+zcfHRuvjgknTfh44AUEJvm8V/Gwei8Jx+HIqHHP+n1T86Bj/EfGD/+nuPv47/vj/8p8T/PxePx+J96/s/YZOeTmthkAZYwEjzg8U+sCrL+9+N//+Vv//rHf/z5b3/953/8/U9/Ov9/+Rf/8ds//a//+u3f//j3P/31H7/901//8y9/+cNv/++Pf/nP+I/+49//+Nf48x9//Pvj//v4cX/66/95/Pko+H///Jc/nfTff8C/Pp7/0x5vkMS/7o/UqALtGLdLdMsF6NwaSjx4LUHPS7TzKiIq0NGrQD8+/oz+vEB8nDIKPE6gnxbg5wX8PDuMAu6vFdBcgnYc9LTCbj3KqE3xuGn3dD3a8xJE5259rcjHs2CU6PyhxNhtTcmFcEEBtds/Q7FHPe4CPv0ZbVPjca86l+Jxqxq/Qz+uzHM4ytNdis9TvWuDiNDTErTbqXKfeFwy4XeI3K8g+TMel+LPK2x2K4rRjNcWbQdqMH0sIZuFOM/yr1270fOF0M1CdM8SxOvOLf7a9rDn22O3VxjnBnk8nOCnJXzzS6TVLxFrz0rQ8e42pc2qoHgAOLeptGfblDY7Fp13E2ZqPy3wxbpsWJfj6Yp4P/F2JR4RU4cO982hQ3c7ltVyPLZu1TiPJB9qbHJTjzz+KOlSgW7/Ej6O7FN+HM2e/xLfHQWlWuRxf2mpoR+Pg5vt2prVztXa43J9qfLxiN7b++u007vrdPtbKN7RuRaDWpPnv2WXoM2QoMOXJfnYsX0ToWS1delxBx/d8o3f0l3rt7C0579ld3xXySL0eJyE39I+nSntDvDx2O7quTO1sD4+LYdvT/lyJ+uPY8PzGrvlIK4zDRrPl4M3+yl7LYcchz9fju2W0aPa7rF19emW4b5bq7WHdLJNjd2eqt5qL+vH8xq7PZUoE5Woj9dqMHMd7v15gvAuUTlXx+MBJ44N/ul8euzOyEcdXpo/L7HZTR9n0cggOZ7WkN3uYTEE8VqQcxLf51U2O6rQyM0i5Mvu8XGNyi5PjWqVGo9nJbbrg8RqfYznm0U2O2l73CnodZTSzs+3zG5XtzqLeuDzdtk2bu+1Uh8XOPq8YcR2B8wh9Xva497Ck3CX8bseHvios/TGayx//i16/K6HXNbaRR7szw9Tujs77bieX68iH8fzjzX6u+t0uxTcKgqZj6dLsTsloxgjO08erD09JVPdXRDX1VO35e7E41Ttdg3udS3K/cOe/qnGeP+kTv3tE+XtGq1Ll/NY9XSNbmtQR43NVrG3bznZ2/ec7O2bTvs1MapLHvddnq+J3QVU9zrS8npgaR9PkM12J4RU+3gf9rzG9kKujgmPVtvU2K2P3urURVif1tiuU+XKDf3wW76xh2qtU7IPy/Gxxnh7Dx1v76Hj991DrQ4o5Jt+H7v7T4fhhklfj40fk2ts9tBz3rVZw9YbHt+pcY6TzBWqHy7hPtXw91PYj981hb3XhaSbvraP+6iLwMeDzKc1vL+7jzu/u4+7/J77eI9ZkubFX6fna8K2l6F1Fdo/7ON8v4ZLHRePwc9r7PZP7VoxrH2sa+TzDfzdXdJ6JjSWA3T/dBK5v0N54A7lcudbbz9Q4V6r43Fc082TiL59QFa3WtuHxxn9G0XosP95B/lcRN5/onHo2480tiXuPdM4xvsPNQ5/+6nGbg+7/Vjj9lbZPdfY3jyqGy6dNseVeHf4vSBs7e2j/b7EvYcC+9UhFYVdt6tjd7y32kHOuRKfPgrdFxn1LNM+NMwvRfwHnkQe7z+KfPu5Vds+dbrZt9Tf7tvds5b7jyP9/b7d7x5a+9jwF/exc06HatxlQX4pQrtre+nVd7ocsz8/t9/3ndfogf64sf687/Z3kO7t7bvHTzf39m2Je3t77+/v7buHTzf39u2zp7t7++2t8upRyuvOzeNpp252j/EDu4e/v3v4+wMz2vu7B9Pbu8fuwdP93WP83rtHpcdj9xivnSjz0eo+58GbfWz37Onu6CH+gf2U399P+f39VH5gP5X391P5if2Uf2A/3e4d719XGuXVHJv58+vK3XMnpboDo9w3h/3dgyc/8Ix02dF/Oerv1wdhfZC9uE7vjczS3X7KuCX1eAD9vAa937Xa3+7abYl7XavyftfuHhrdHfhnP9C1t7fKpmv3e0eNWnnsHfpaDcHtMdHnxwVru1uvR97Y0qPxSzUkPqz1dY39b7k1kLEZv72nb0vc29NN39/Td4+fbu7pNnYjNKgijJanxb/s6dvHT7eGZW7Xxr2xofEQ9c2l2KwMdsnLSfalU35dGbeLjNeKyFGjXuTYbpZtEa1te6zDkb5XpO6OyeOO4ItFWt0xkOabImN3FuRHDWl88FhiucmrEfJ0CHDbPYky3ACxzSXQ/tThzkDk5vQDVw3bIr2S/XE+trl+8e24JsW4Jnt+iPEfuM/v79/n9/fv8/sP3Of3t+/z0/ET9/n9B+7z7/cOrI+xOfDvajweJeFZ4+Z0/Ysax9s1uNVRhpfn+t+qgZEnj3JPa8TDszdPyLY17p6Q7deHaf0WH2/XkINeXKd1cfp4/Pl029LutaXHLeQaWGm8OaHaLojhNMS8P18Qfn/j7mr8yMbFQaqP3XLsHs4fjnGm6+jub61UPJB6PJp//trO7skH17Nopk2i0nbordcYAT6en9rtl6PX8XZ9YeaX1bE9ZteTQu4fRqp/evdn90Tq5o0H2j2SunnMJpJ3j9n7EvfeTdu9CnXzmE27p1E3j9nbwUU3j9n3t4pttkp/+8bDvsa9Gw+0exp1M8a+WI57bz/29/fS/gN76e1f8jwHdw897l27bOOH6xUm1mUs3y/xw8e74zZo9yjq5riN/U9pGCu1ufrZL8fNwR/bBfE+cJlNmwWR99epvrtO9yV+YHVIw22pxrvV4b/nni5cB1oRf36FTbJ/Ww8/BSX8U6LvHkTdeyuE9q9i1f2GdbD7L0uxe9m31XUL03qOfb/E+bym49mNHK8VwYDP8+s87cUiONtv64P976zUGuQtY7dp/XctcX4qTbBS2/Of4j+xZfwntoy/v2X2nas1Mkh8HRn0nXtj2urX6Me3279VpPr/sUybk/XdA6m68bmMT+LvLATXiHOV49XV0a1XEXs+QJHs/eO+vX3c35f4gWOUSi2Hatutjl0Mife6qS0uT3vXNsd91Xpd7/Fof3O03D2CeUR6nQqRP38yT7Yfil/PcY7+/NJj+wDl3oX67oFUGwemHTg/Q/f0UcFXG+fo2DjLqe43ksh6nbPb43bf840z6O0b7LR7Leruxfp4+9npvsS9y6Dx/rNTGm8/O6XdA6nbF+u3t8rmYn2/d9y6wb6tcfMG+1c1jrdr3LvBvq9x8wb77sHHcuNB3O2lGnfv495cjm2N/TrFi1rrHCy/LIf/wPrw3/u33HrgcLvG5oHDF/vYrQcO/eD3HzjsF+TeA4e+e7np5sbd1ri5s99djtd3kHsPLfruFam7Dy32C3LvoUVv9O65UN+9IHX3ocV+OW49tPjyTJeXM92n84XspuS7e7q8LXLzPsb2PNdqRqpmutnJ3n9Bqr//glR//wWp/gMvSPX3X5DqP/GCVP+BF6S+uAqqqw9a3wn4Zcu+/3B+fyV1s2t3z8XiLdC5aam/tDqo1Z0lassV++fVsXux6WYQ7mbmux2E2+W4t0q/uL+1HF2OZUzdd26SPf6howg9DcKu799p2xb5kbvCd9cI/8Aa4eMH1siuyL018sWAyVbv8jR6dfxnO/BMidrzItuXPXHAfdxltqe3hfp+ar1bYw066/uHy92oy5uHy22Je4fL3XOpu4fL3fx8Nw+X2zek7h4ub28V22wVeXuswb7GvbEGXd6/XN/WuHnY/uK33Bqv0HevSN3c07clbu7pt3/J8xOh3Xjte09x9xFWs7LYenX7S4Rpf/+MX98fLtX17YEo+xL3Nqy+P1yq69vDpbr+wHCp+1tlE2HbvePmGf9uar670bFfjlvPX7rx26fauwdS986S90txr8R2Ls171y5f1Lh37WJvjzyNWV3fvnax90ee7mftqCnpRhvPv7Sxn+Hq3pu3/v755Hj/fZM+3n7fZF/iXhiP99836ePt9026/8D7Jve3yu59k7dPJ/ffy7h3NunvD+Lf1rh7E+jtO4T0/kwK3d8/1m9n6Lv/+t/tL6E8PVDz8e4Z6fb7H1bDTx6BvU4O2j4txXZyPTzk7Ou+8Y0SeI/gw/S1n0vI23d/ditDvR4aj0M2K2N7YX/rQ1jHduL9W5/C2pa4+WkYfXeTbD/qUpPqrZPI/TJL6q6C4iMG43mF7WOaun11TtG11Oj3a3A9x3vUkKc1ePcRqOZUXxd7sD9bof3t23n7r9Oo1owlj4e+6witz1/9GG93/LbEvY6n91fH7oBimNfY1gz+9HTk3X18W+HWPr79WNDNfXz/waGb+/i2Ue7u47tHZ1S3ij9MT//L14J2NQQTiItsamy/SkN1kfJgff4hBt6Vudkp2xL3OmW3j/1AcHxaHf50dew/n4QTYl0+j/jL55Nu17D3ayzDXb71GadD62zh0OefPuLtvG/x5dRrrY7RN0V2V0w1/mdwe7FETR03licr3yvBtRQy3i6h/bUVSoIvU6zX0t8sgsOCNnlx03qr60ffbZe2OyOtq5Wuw1+q8bhBUdMC9t0udu8zX+zj+da9/cmyXY27n1+z533L8u5F03YpDJPmj6NvlmJzxWNSnW+yvjn9+TNh26kGBo4M6+ME+1Rj92DEl8mK1tf9PtfQ7QPv+trYg5fv4n3n2DDIa62uB+3v5Pqo654H6vMa2yOdcA0BeCTB8yMd7z4F5bhFcKw3Gow+rdfdHV+skSabT8nt5n4b9TjA2/OVui2xDIlYnyj8WmN3/+je99d497To7gfYtlPhHfV5vrZOZ/Xrj9mOqsJFlPsmAHYPne4GgPr7AbB7DepuAOxeYrodAPtt0/EJtu702s76sYhvwnl3DYLDDI3Nmf+2Bu5VPi4CXqvRFQ8Xjs13ILfPzuucarz2EUfG3fTHReJ4qYa0GvcvbWw+Wbh79KRalyAPbK8VsV436KwvQ7O+WWRIFfHxYhHGtw249xeLjHo+YOtJ87c2DtdwNVlfUvlWDas1IuNoL9aoKyoZtNtJdqfd/agX9h+8WyXbr0QRBu8/WHe/aHcyIYJRfKLH8fLS4JXox9LsGnk7D+wQfGlu2Hh1FeMLxg+WV/eYdd5Be60GBhmIL58w/tY3ao/ac7W115ZDW125atvscrtxdDfPbrafylWpmH3w8v7ttz64qzgzefB4tYriXqDaYS9WMcIvWj/k980q9UjlwZvA3lcZ9Rz1wa29uizL2h1tt3b1J/JJdk+rznxaxh64v17mXsx99aNuxpxs35l6HDEbYm63ir8oczMtv9jesux7+vK+V9MSP1he7SbHTqOu/GoVfJBb3fy1Kkb1pdCT5dUq+Hi0Pa4xn1fZDZD4kc9yG57CDJP2YpWBVwfGaMeLVXxZFt+dKm8nS8WHgm33pHBXY2Dg2zjsxRqCG0P6/Cpof1PH0T/9OJ5/3lto+2bpne9+7kvcemC4L3HrieEX31xfXi7x49nsOLJbp94Mt5aePpfal6CaTcqJxivPpbrghk4XG6/tHh2fC27d2vMq0vndh337Erce9sn7r0F9Y3XQ6ysVPWf9xc49P9mOKvL8Torw289h9yXubRr+fZ/Dflwdu+ewX2waXCSbHU+r7G5x34uybYV7Yx+2J2m9Lx9P39wkk91dsnsDQbYlHmnY8fl05ReL2HI+s+7t3ytSD6gePPSV/ez8YG+tV+nPD//7D89onVk92NtLVR63UutEpB/r42l9rUaj12pIzTb6uEHcXqrRMXS0Hx+exn6q8f60lrsSfLR6oNvWmw2f7vpva7S60/7INX5aQ3bvVN3M5W2Je7m8e7fiXi5vVwZ1vFrx4WT588rYDWH1um593MfTTZHdzCWYGm+5fPgchvvFUCyG9Vd/CyYb/fhx+u8VwXdj5OW1Wm+sPO4+HM/39f38BfWBk76r4W8fLv3dw6VuP1N7b6jgtsbNoYJiPzBUcDtxmtTl2BB6Pvuz2NtDWfcl7gXQeHso635l6DKE6/m3g2U/bdqdlbGbNr5TvUXU+/qOWfu8NrZz+90ZQy+7t3fujaHfl7h3mPUfKLG9VMelGH34tBJ/+imbreJ1U8mX2RfsY4X9Ky/32nVbQ2NWpnnfkJa3Tc6vpN2vglksH7wcWb5bhVCF6WmVtvuwEaZKXyeA6p8Otl8sCN6n1A8vVH7r5zDjMQmvTwO+VUWWVSvLC5Gfq8juDasfKkMH3o861luYn09ltkUwe/vjdrO8WIQqWonseRHffseznh3RI+yftrEe78/Q+UUNNKG0/vwMYFvk7mnEfknunUfo9snT3WDabRvGTiI+NttmO4iiRmHLh3mtP72PrNtHTvemdtDWbu4kz98m1t0ke/de1dyXuPU2se4+HHXzdU/dvXZ173VP3U3Sd/dt4vtbZdO6273j3tQO2t6f+PSL5bg1tYPS27Oo6W6uv/tTa++X5NZcBNsVcnN6hy9q3JreQUnfX6m7PL05vcN+OW6t0i9OaJYRG7wMGP58DqHvv32l7799pZ1+1xL3rg+/WKMYkf5Yu/J0je6uzG5e0OwuVB83tWvspLbnX7LZXuxivNXoxC9e7N7cLP72ZfvulSetKUjGelvo8y/xt5/D+NvPYbYjFG+eEW5r3D0h5B94z3o7q7/UfVhaBxp/3ijK70/Mq9snOTfP5XZjE2+ey21L3DuXk/en7tDdt6dunsvt3rq6fS53e6tszuX4/Yl5Vd6fo/yL5bh3LidvfyZF5Uc+k7Jfknvncvz+NMNf1Lh3Lrd9JHVvpW6nk7t7LrddjnvnctuBzTW+eshrh6caMavj+bAre/+8ZTd3dKeafvZxk3t92iD3a1gdqrt/GIR2vwYfVYOPD8NhPu0a9vaN/v1i1Ak6t+1ivD/h4Rc1bt7Q2n8S4OYNrf2S3Dx/sfH++cv2o1MsGInS7PlutpueCqNZSFVfqyE1mIUea+75PjLo3YdBuvuy0b2HQfsSNwNku0aX8bSHbtbGD3x2Qsf2Bfbatv348JDu85LsjrU3v9Km21P+m6cfu6PDzSOltx85/fhi49z6ShttP2066pJyPXf4PAmZ+nbo9q2PtKm/PytlDCR889rD356VUv39WSnV356V0o4fmJXy/lbZHDH3e8etj7Rta9z8SNtXNY63a9z7SNu+xr2PtNlx7yMpu+9WbWvcnKfz7nJsrwn36/TWR9ps97zj7vq4WeON33LrI223a2w+0vbFPnbrI222/eTUzY+07Rfk3kfabDd33+2NO97f2W8ux+s7yL2PtNn2SdTNj7TtF+TeR9qM3p4w3Ujev2mwX45792G+OtG985E2o/H+2fK2yM3BwdvT3Hv3gq2//1zf+tvP9fclbp2PWX//uX5cpLx5PtZ/4Ln+/a2yOR/bXwTduhds/Qee628vpG52rb9/93Rf49bdU+O3754a/8Dd0/1y3Ful/u7d032FO3dP9y++1DXpA9dpCL/x8oziBRz1/lqNUZMV0Hr79Hsv4OBE7KDnv0VkO/fnvbd4tkUe27Oe2w57+grutoRXu6mTvVYCT4/Xr6p9Y6tYHajJ1inVjldr8Is1CDX6841i4m/fGN+WuDWuwN5/pWlb4uZZy3Z96v/4TuT3tslyz9NfTI51OV6tgdOWczqBF2sw3arx9rMwfftZ2Bdv3dfDDid68cX9mmb3gU/fUt3OYnBrVXxR4s662M8tgemCP5wSf2t+iobpYDfvyu9r1PksrfP0fa8G+mT481e6v5h/hDFzyJDNVFb3q+zmofqiCqOKPZ8hJkLm6ZnxvZlHbfcM6u7cXPs5WQhTfftm5sEv1gmuNx4b+eX5YdZl6S9XwRX6cH5xNiEjvMD/OIL3V6voMg/Qy3MS4TXPBxO9WoWXKvLqzEa9r1X01SrLPcM+Xl4vtlTx48UqvMz4xPTqluZjrfLyXodpYh9XcJts2b6cx8vLaLzbYb4qg6kjHgvTNmW2j/3vTlj21dLUhcmDN9MZfudHvVHGMBHFOi3w5zJj/7LRT62b5a7AOt3IGz/qjTLcML3Gbg7ZsX2H6qfWDb6F+GCWH/lR/Gp8HgfGwKyfT//mVHd+LFWe73xfzPRb84U/0F8sog3j5sleLCI1uOhxDfvqz7G6cWrj5XmY15/zehF8y0Ht1XmYrUZ7mzV+dUlquotHEXl1SQSfphD+ga3TNpFAPzRT8HZ26qa39pTtJOgdE6nLZhKx7Uel6pMOtI7d/PxBqLH9IN6tW0Pj/W/qDRq/a4mbs5Dt1mfHTEjdnn9ga+wendyaqGa7FIybS+uz/V+Xor99eTh2C3Lz8nD/yTLC10BJnv6WfY31W7HP1wfTdszmvW+nbYvcu7W9L3Hr1vYXJe7c2t5+m+/WPap9hTu3qLbfwLy1DPsKd5Zh92Cwnnbo+rKd6N0C+CiXfHhoPO4WeDQp7r0udxoeJ2h3S6DCWKfW+jh/0+CbEzj11yoMbInxYoXsTjueLsPudVbB6NLl3yvf3hfqns/6DmlTub0v1FAI0dcK1L2IDx9n+kYBr+24rsPXCoxXCuAzZvraOtBaB/raOtD6CfbaOlgLvLQOMCTGXlsHVuvAXlsHVj9hvLYO1gIvrQMcJtdvt3ynQF1Yrufo3ylQFwv+2jpYC7y0BF7HN38tULAEYx0vfzsSve5arCcJn0PZdjeX7n7+apcpuDkqH+6Nmt1P1spmEX6xRD3LelRrr5SghheH1m/DENE3StST/LYMl/tWCQw3oWU6nu+UwDPOx/UjvVQCh+uPg16+UcLqEpqsv7Y6qb6r9Hjc+1qJXi+2PNZKe20pMHinHy+tTqlvwchra0Icn+mRVwq0g/BZR32tRMOHlNepd79VQhE347Wl6Mvc7P7aUiwz7wvbayUUoyeHv/ZD8MGMdTbAb5XAc+Yur/0QrRZr643I75QwwxMpf6k/GuZ5bE4vlbA6kK0fW/pGAa87Qy4vrQevoZvrQ/LvFKjmcJM3f8JrBR7d0OtYvn4/6zsH4noS/UB7rQQJjuXHKyWayTKR/Pq++ueX97dz6+Pa3ejZOP79bl1Z5R+mQP1Gc41KzPWNlV9+yO59pHtvIvtuVrx7byLvS9x7E3l7bjTweVM6Nitj956IGraK2vM5qb4o0tePY/WnRXZvMwvGnMuHBwSff87uTZHly9EfV+un+VN3k+sNfOV0NLFNke03rHl5Obs//zm7Se20dZzpLK8l+PhGDa2HJqrLU8tv1Ri4dbjexf2lBr97+3Jf4tb8Vvtfgg96Px4Eb9bGbvoPXKr2dbxUOz4X2X59U5avb7qvM+PKN5YFL4xwW7/M9XlZdsNAb+/wuzVrOpanns/31f0UezUefxkw8Lljts+BcJ0lHz6Iw/apyO4dvvXlgvVB0Oci2/WBmWRtLHn2y/rYvT1nDeMW1pk35NORpu/eJT5wFnNsSowf2ON37zZ9Y4/fLsvdPZ7bD+zxuxWLj+KN9fMan1fs7sUiwnc7H+dXzydz9N2I4Z/5MRhIdyx3Bn79NbtX8RrjjKRt5kBn+4lfs33HGt+btbH7Obs3QI46eX9cnW6K7MYe3d7C8hO76/bnNDQxLRf6v/6c/gObWPj3Pt44vgC/fgP1c75up96jOvl9XGXp8yzZfoWRCWMJl+ei/mnqz+2baK3uMD4203J6ND4X2e6vdVerr7ekzvspH4ro9lygfs1o6yC3z9tm99bS3bvg+3VCOAr35TnrL+tkN+/d7V1tuyTcMJPGciPg1yWR3WEYZybH2n76jf1Va8Jc+XDM+by/6k8E7O7y5rGDYdKXY3Pxqf4D2WjH7/1zqCMb11mwPv+c3Wx8t7PRfmCH3Y7zqA8qPe5g+Ss3WljrWwpsvLnRYvr2jZbd9IQ3b7RsS9z8eM8XNziWL24//56jj+MH7pK8/4Wp7b5+e4XspzfEvTx5+T7LzUPNvkg9eB7UNkuym6XkcS5Roxh8fVvulyK7DBGq65Lnd7z3dydwraayfOLpe3cn6t5/9+UTQt+8I3Bz0+yL3Nw0Tj+waby/vWm29wQa5nwl3dxY2E37hntP6Fzu37kOv7lt99e+N7ftvsjdbevvb9t2HMf7G9e251V5WrV+OOjThdEZl5tkxrhy7suMFL/sINv7AbhuJeX26v2AuxuY39/ALS6Sf2AL2++6hfGmrC9vcv4PW3g3OU+rmSmkrUNHf9nCu1P4hn2N1hstvxSxn9jC9hNbuPWf2MK7b0Td3MK72xuEp+a0PrP+dRu37bd3uLr4WL+G/HnzbO/53O1i+YmYlvYT25iOn9jGu5ObH9jGvdW4tv44hd5sY9rN5jTqZJ7HOljxl23cf6CP5SeSWn4kqXenjd/YxuPtbby9ndY7hjQtt24/3U5rR397ePu+xr0R7l/UuDXI/Ysat8a5368xXqxxb7T7FzVuDXj/osatMe/3a7y6Pu6NfP+ixq3B71/UuDX+/X6NV9fHvVHwX9S4NRD+ixq3xsLfr/HqctwbEf/FHX3FIJJ1NpRPd/TbsT1q9nofuX+Y9eN7Vbj21S7HeLUK5iDsus6e870qVrcWz4l///v5k47dQ4qbY/O+KHJvpP0Xz1zuHsHlR6615O1rrUeN7eea743a/6LKzYH7X1S5OfB+/wAIn33u64cKv/ko6u6Ttf4Tu8ruk1L3d5XdE627J3vbJ2t1svd4staertjHgmwfRtVj3L5+HvzTo7VHkd0t7eUW/4cDun0u8u67pV+UuPNy6Vclbrxdun1YyV43s+TD16k+r9HdoyzGWSfrOvTo9SL9+WPT289vdbOX7R5nNcxG3LiPzc/ZfhyCMcGz79bJbldtGLfw4HWw7DtlNs+kt8MfjnFr+MPuphjX+Zas76B8vq/9+N+72U7agVdy1slbfjm32H0iilul2joX3i8NOH4kX4e8fyjefgP19qF4W+XmS19fVLl9KN7tKmKVTLreZv9lV/Fvvz//yy0Gb98t8fkV/C9GYtw9I/iR27j+I3usv39GcHvcPD8fN/9YkF0ojWVOy2UoFH9ndMrdu7j2Ew9S7SeuD9rRfmATt91jrpubeDdO5vatU/uJs2nrP7Ji9UdWrP2uvdMx72nvH75C/o0ijycgdXf80OdDoR6H2OP3rnJvAqIvatyageirGnemIPriQvTmu9dfXRTfOxJ/cdPi3iuFXxR5e5oCwutN1Jb9lX/ZR3YxjQ9hHU9L7Bbi3mdsHjvu7jnbre/YPGrsTl8dn6N48PrCabs/p01NZCsfvopBLxT48BGI2wW0LgfW+3vfKbBcQ7eXCtx6TWz7lOLOXF3bAu9O1XVrmN9usCHXWzKNlzdl+/2pTB4duXwHmV8qYcsU2vzaUgxdZkrXl0p43aNtvly4f6eE4g1qtdd+iOLrcut3g79T4lhe0hmvLQXViNpG65Dab5TomKN9/c7mt5aiRlk00td+CA6nrTd9d128XEIcP2QN3O8shWGL0Psl9KUSvd7uf+B4rYTiwb31l0qskcOvrYuOLyvwh49LvVjitY26vhPU22slMBcJq75YAj/kw/yu3yhRlyWNx2sblR1fgDyOF/cLTDBDL21UfPz1wx3g+wWwawo9Xw+t6T73GHGxnCh+Y34xvFhlL/0Mq7MrfmlbiOD+G79UoObwEO+vFahBNc7vFVhH1HxrJeIm/ktZqXWTWbu/uQSvbcbHU4O69tL1muX4fGFsbXdRa7iodTSm/VJkd0uJCDNyL9dwvxbZTd4njm94yHqh/+ttGNvNvtzqzSdanyV+Pilocevo3dOsL6rcPNP64hdRXQ8RmbxymrNO0a3r3e5fdxbfXdRUeHEbywfav3Fkxkj9x8pZ54n8ZUl2H5NqHR9O6h/e++2fq2y/F71csB/HMvGZft4+Y/tKteK5yOPWqLyyYhi77ePcYx1vdNy/ZsT7i+cSV4nPg2vb9oPPN4dv7ovce6X6UeQH3ql+VPmJIVht+7zp7hCsfZW7Q7DaF8++7g3B2le5OQTrq7V775X1x7LIT9zG9x+5je/vj5+K+zvv3uR9VNnNt3JzeskvqtycmLHR7tnTvekE9zXuTtp5e0lMXt0+N+eDfSyJ/Mia1R9Ys/o7r5ObD/cfS7Lb227Onvm4GX+8v07a8SN72/ab8Pem8vziSHZzJozHL/qJ90Ro9yr87ZSk3WtWN1OStiMF7qYkbd9kv5uS+2W5vffT8RN7P/1A1tKPZC0dv/vef3eMKNFuaMrNMaK0+/DT4/FBXTc4Px+duS1CRw1Tow8zQ/5SZOyu/298demr5cB0JYf68+XYv+D0/nI0fPC4DX5xpTZtP1Ck7m29UWSNJdrsI317boAk6OvUY98qgqGMjwuqHykirxbBdGzrqMrvFsFAU/Ef+DmvF1kero7xfpH1Yu57RdYb48sDk1+K7F71v9nD++VQPLjZdc721fhby/HFseLeTF3XA8inC3Jvqq59kbtD6Gn3JvndIfTfKPJ0CP131uzmbgrJ9vu998bQk2xnEj7wFikdLxYZdcNMxzob+beKeO32Hz4r+60iRnVP0z7MPfa9InVG/SjSXysyjioyDt/s99tnXLdfTvhWGXvxJ/X6KuzovFm52n/mJ/Wf+Elf3By99cLF3Ru9yyO0zzd6aTfu/PbbFqTbj5jeetuC9CemESJ7exqhR432E5ekRj9xSbpdltuXpLuHR/cvSXcPsu5ekm4fht2+JN3+nve/rXJd885ne/z8MQntnoWdM5RUlYP4+bMj2s4peCwD0w5dznh+LdPe78JBP9GFo7/fhWP/wPPAA8/dnv+NVbscDr+3hZrWg5IHC71cpt57erDLpswubutGIq/PbH7d0NtJeHA7hnY1fiD2/SfeZyGn93e43fSC96PWfyRq/Qei1n8kav0HovY7O/46W8t3hg10DG5cBg18Tuy+m2aQqB6bPu7rLBcM/rnI7qA8agq5x0P6timym2mwHfgCwhIo3yuC2RV4Hbn6zSL1nP6dIhUoXxTZrdh19rf2YpGOU9re1mEu3ytSbz715u0nivCzIncHbtrzc/y++1SWeL09rMeyz38+5vTdl64apltrY10h6t9YFG2Eu0N8bBaF93eJ3x9q4zU2ZZ3U69cVq9tzSDxJeDTR8mpb+1aZjitK6suh59cyu3s7hjEu62fZPw/A67v3sL4xAK/T9qWwmwPw+vYB1t0BePsqdwfg7X/RzQF4X25rxnVHX17/+GVbb5+DGWapXT9p8s1FwWdHaT2D+3VRdncQfPkuoa8fJvylqWn8QFN/tTQDozqOo/fnZbazfongFs86C+ntYXhKmAR8ffcrRvL978f//OO//vnv//yXv/3rH//x57/99T/Of0lHnBw9fh21IirqRRy3FB5ykiINeqQmWdEIevwS8qDHv+1HUSuiol50OuIndCnSIisaRZ7ER1EroqJeVA4uB5eDy8Hl4HCchyk5itoVxA+iol4UjnOPkXCcT7AkHGdyi10d+aBwnDP7iydpOM4zcW1F4TgHXWsvCsc5gauG49x3VIusaBSF45wgw46iVkRF4TjvThsXheO82WzhOEPfrGjkFrTa5uNyPNbVaEXh0IdjhOPcrwZn4g4p0qJwRL1RFL/jTBE/roh+UPttvtblFPT4t97r77j+Tn6bg6dcI6rO/68FPX6HjyKPnn/8fx/ndcAGDM15uGlHeM5t3A4Ghily8v/98e9//uO//OVPZ7+dLfmff/3XbL/H//zH//fv+f/5l7//+S9/+fO//fO///1v//qn//Off//T2arRpcf8P/9rnNdN47GM//vhOP/3OXm9H609/neP//+jMR//0XH+/89/oPw4NXr8Hz3/Iv6FPnbCx//pZx60s278d4+y7udfUf3V43qD4q86/sr+0On8K8ZfyR/6cf6V1F89MpXa+Vd6/tW5WI+LKKZcpMdOK3r+vw1F2h/o8VdnSP3/",
      "brillig_names": [
        "discover_new_messages",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "admin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "end_vote",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "8095637994846897154": {
            "error_kind": "string",
            "string": "Only admin can end votes"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAACXHgIAAQAeAgACADMqAAEAAgADJwIBAQEkAgADAAAAaSUAAADAJwIBAAEvCgABAAIeAgADAQoqAgMEJAIABAAAAIslAAAA0icCAgADMAoAAQACJigAgAQEeAANAAAAgASAAyQAgAMAAAC/KgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQVwWXvdIQFEAjwEAgEm",
      "debug_symbols": "tZVLbuMwDIbvorUXIvUic5UiCJzEKQwYTuDaAwwC332oNvKjgLSYopuIsqPP/PnSU12b8/R+avvb/UMd3p7qPLRd176fuvulHtt7L0+fSscfz+pgKxWsOgRZZAe6UhRkhUoxfq2gdTKcGF4M0MnwYrAYCOqAOhr+ZRibDOGiE8PGJ26eK5VcOY1D00RPNr6Jx496aPpRHfqp6yr1p+6mzz99POr+cx3rQd4Ku+mvsgrw1nZNtOZqPa3zR8E4b1/HwXjmBQHa7yBQgGjExNAWNwizQ2AeYYnDC2FZvpwQnncEkyeQNSkOZG2WUJTBnGQAcFaG+7EM/7syHC3ZoHw2qIBwwSWEN5BzgvMEdjo5wc7BD2UA5mWUipspxRKYaUG4fXtAoS4B7BIJCGuDAbk9o1CZgSC1RyBjsrGwBYSPY+cL4Z3OIlxZyVreljEHKQQUtU7DAvUmJ98DGvIIp0PKiZiUVUKlFlmajBz8j45NYYgOl9NRjASnusDtrPhGwFKBW51yChZDtrSwUJ6Ey/QmpOy0wNLc1H6JJkA2IWhLpeX82qte8w5ylF19aYfdtTtH2tDW5655bW9Tf9m8Hf8+0pt0bT+G+6W5TkMTSevdHa/gN6TKmGO8h2VjQmX4OMdP/wM=",
      "brillig_names": [
        "end_vote"
      ]
    },
    {
      "name": "get_vote",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "candidate",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_vote"
      ]
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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ttlabk4uLHRiAwVU0MBRN2uNoDipTKqT2iS5KFfiatkKci2uEw10sIMxMRvwiQWsYAOxBbbAFtgCW0zbsVLXiQWsYAMFVNBABzuIrWAr2Aq2gq1gK9gKtoKtYCvYKraKrWKr2Cq2iq1iq9gqtoqtYWvYGraGrWFr2Bq2hq1ha9gEm2ATbIJNsAk2wSbYBJtgU2yKTbEpNsWm2BSbYlNsis2wGTbDZtgMm2EzbIbNsBk2x+bYHJtjc2yOzbE5Nsfm2Dq2jq1j69jIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSU5m7Jl30XOprwwJl7LEVe71iOudi1IXO1akbjatSRxtWtN4mrXosTVrlWJq13LEle71iWuZtNh02HTYdNh05EteywCUHP65IUO5s5oYkzMli251ni27BMr2EABFTTQwQ7GxI6tY+vYOrZs2ZKnJFv2iQY62MGYmEvwPpLKpDqp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",
      "brillig_names": [
        "process_message"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2024020833944022298": {
            "error_kind": "string",
            "string": "Function add_to_tally_public can only be called internally"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3557153117338734214": {
            "error_kind": "string",
            "string": "Vote has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8095637994846897154": {
            "error_kind": "string",
            "string": "Only admin can end votes"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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LQoFBy4IgEoACC4IgEQACQAIAAQAJQAADrgtAgAALQoHAwsiAAOARgAECyIABIBEAAYkAgAGAAAHRyUAABAiLwoAAwAEASIABIBJAAMtCwUEACIEAgQtDgQFJwIGBActCAAHLQoFCC4IgEoACS4IgEQACgAIAAYAJQAADrgtAgAALQoIBAsiAASARgAFCyIABYBEAAYkAgAGAAAHqiUAABAiMAoAAwAELQsCAwAiAwIDLQ4DAgAiAgIFLQsFBCcCBgQCACoFBgM7DgAEAAMjAAAH2ykCAAMA8hn7/woqAQMEJAIABAAAB/YjAAAIKycCAwQELQgABAAIAAMAJQAAEDQtAgAAACICAgUtCwUEJwIGBAIAKgUGAzsOAAQAAyMAAAgrJwICAlUnAgMCbicCBAJrJwIFAm8nAgYCdycCBwIgJwIIAnMnAgkCZScCCgJsJwILAmMnAgwCdCcCDQJyJwIOAnsnAg8CfS0IARAnAhEEHAAIAREBJwMQBAEAIhACES0KERItDgISACISAhItDgMSACISAhItDgQSACISAhItDgMSACISAhItDgUSACISAhItDgYSACISAhItDgMSACISAhItDgcSACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDgcSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDg8SCyCARIBHAAIkAgACAAAJ9ycCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQUnRkiy9UEXvQAiBQIFACIQAgYnAgcEGy4CAAaAAy4CAAWABC4CAAeABSUAABB8JwIGBBsAKgUGBS4MgEkABQAiBQIFLQ4BBQAiBQIFPA4DBCYoAIAEBHgADQAAAIAEgAMkAIADAAAKICoBAAEF96Hzr6Wt1Mo8BAIBJiUAAAn4LQsBAy0LAgQLIgAEgEUABSQCAAUAAApDJQAAEMIBIgADgEgABS0LBQQtCAEFJwIGBAIACAEGAScDBQQBACIFAgYtCgYHLQ4EBy0OAwEuDIBIAAItCgUBJiUAAAn4ASIAAYBIAAQt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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3bzuTKkWb5Lrqui/CTmZtepdEoqKvVDQGCqqGuGmBQqHefoJFmyzOzwpN/xK+50V7aO9MWg6R9PDmd//GH//nn//Hv//uf//K3//Wv//cPf/xv//GH//H3v/z1r3/53//813/9lz/921/+9W/Pf/sff3gc/1Nq/8Mf2z89/zn+8Mdx/FP+8Ec9/ql/+KMd/5x/+GMpB9gTjj/ZHgEloAa0gB4wAiRAA2ZAVO5RuUflHpV7VO5RuUflHpV7VO5RuUflEZVHVB5ReUTlEZVHVB5ReUTlEZVHVJaoLFFZorJEZYnKEpUlKktUlqgsUVmjskZljcoalTUqa1TWqKxRWaOyRuUZlWdUnlF5RuUZlWdUnlF5RuUZlWdUtqhsR+VjP7Ia0AJ6wAiQAA2YAXZCfTwCSkANOCrPA3rACJAADZgBz8r1uWPX8qxcxwEloAa0gB4wAp6Vqx2gATPALqjPyu1xQAmoAUfldkAPGAHPyu1QHC14wgywC44ePKEE1IAW0ANGQFRuUblF5RaVe1TuUblH5R6Ve1TuUblH5R6Ve1TuUXlE5RGVR1QeUfnowXZs06MHT5AADZgBdsHRgyeUgBrQAqKyRGWJyhKVJSpLVNaorFFZo7JGZY3KGpU1KmtU1qisUXlG5RmVZ1SeUXlG5RmVZ1SeUXlG5RmVLSpbVLaobFHZorJFZYvKFpUtKttVuT0eASWgBrSAHjACJEADZkBULlG5ROUSlUtUPnqwPw4YARKgATPALjh68IQSUANaQFSuUblG5RqVjx7s4wC74OjBE0pADWgBPWAESIAGROUWlXtU7lH56ME+D2gBPWAESIAGzAC74OjBE0pAVB5ReUTlEZWPHhz1AA2YAXbB0YMnlIAa0AJ6wAiIyhKVJSpLVNaorFFZo7JGZY3KGpU1KmtU1qisUXlG5RmVZ1SeUXlG5RmVZ1SeUXlG5RmVLSpbVLaobFHZorJFZYvKFpUtKttVuT8eASWgBrSAHjACJEADZkBULlG5ROUSlUtULlG5ROUSlUtULlG5ROUalWtUrlG5RuUalWtUrlG5RuUalWtUblG5ReUWlVtUblG5ReUWlVtUblG5ReUelXtU7lG5R+UelXtU7lG5R+UelXtUHlF5ROURlUdUHlF5ROXowR492KMHu/dgf4L3oEMJqAEtoAeMAAnQgBkQlTUqa1TWqKxRWaOyRmWNyhqVNSprVJ5ReUblGZVnVJ5ReUblGZVnVJ5ReUZli8oWlS0qW1S2qGxR2aKyRWWLynZVHo9HQAmoAS2gB4wACdCAGRCVS1QuUblE5RKVS1QuUblE5RKVS1QuUblG5RqVa1SuUblG5RqVa1SuUblG5RqVW1RuUblF5RaVW1RuUblF5RaVW1RuUblH5R6Ve1TuUblH5R6Ve1TuUblH5R6VR1QeUXlE5RGVR1QeUXlE5RGVR1SOHhzRgyN6cEQPjujBET04ogdH9OCIHhzRgyN6cEQPjujBET04ogdH9OCIHhzRgyN6cEQPjujBET04ogdH9OCIHhzRgyN6cHgPzgM0YAbYBd6DDiWgBrSAHjACorJFZYvKdlWWowdlHFACakAL6AEjQAI0YAbYBSUql6hconKJyiUql6hconKJyiUql6hco3KNykcPih7QAnrACJAADZgBdsHRgyeUgKjconKLyi0qHz0ox8o8evCEGWAXHD14QgmoAS2gB4yAqNyjco/KPSofPajlgBJQA56VtR3QA0aABGjADLALjh48oQTUgKgsUVmiskTlowdVDpgBdsHRgyeUgBrQAnrACJCAqKxRWaPyjMpHD+qxdY4ePKEF9IARIAEaMAPsgqMHT4jKFpUtKltUtqhsUdmiskVluyrr4xFQAmpAC+gBI0ACNGAGROUSlUtULlG5ROUSlUtULlG5ROUSlUtUrlG5RuUalWtUrlG5RuUalWtUrlG5RuUWlVtUblG5ReUWlVtUblG5ReUWlVtU7lG5R+UelXtU7lG5R+UelXtU7lG5R+URlUdUHlF5ROURlUdUHlF5ROURlUdUlqgsUVmiskRlicoSlSUqS1SWqCxRWaOyRmWNyhqVNSp7D9oBEqABM8Au8B50KAE1oAX0gKg8o/KMyjMqz6hsUdmiskVli8oWlS0qW1S2qGxR2a7K8/EIKAE1oAX0gBEgARowA6JyicolKpeoXKJyicolKpeoXKJyicolKteoXKNyjco1KteoXKNyjco1KteoXKNyi8otKreo3KJyi8otKreo3KJyi8otKveo3KNyj8o9Kveo3KNyj8o9Kveo3KPyiMojKo+oPKLyiMojKo+oPKLyiMojKktUlqgsUVmiskRlicoSlSUqS1SWqKxRWaOyRmWNyhqVowdn9OCMHpzRgzN6cEYPzujBGT04owdn9OCMHpzRgzN6cEYPzujBGT04owdn9OCMHpzRgzN6cEYPzujBGT04owctetCiBy160KIHLXrQogctetCiBy160KIHLXrQogctetCiBy160KIHLXrQogctetCiBy160KIHLXrQogctetCiBy160KIHLXrQogctetCiBy160KIHLXrQogctetCiBy160KIHLXrQjh6c9YAa0AJ6wAiQAA2YAXbB0YMnROURlUdUHlH56MHZDpAADZgBdsHRgyeUgBrQAnpAVJaoLFFZorJEZY3KGpU1KmtU1qisUVmjskZljcoalWdUnlF5RuUZlWdUnlF5RuUZlWdUnlHZorJFZYvKFpUtKltUtqhsUdmisl2Vy+PxSCpJNakl9aSRJEmaNJPSUdJR0lHSUdJxtORUp5EkScej9YfTTLKgozEvKkk1qSX1pJEkSemo6ajpaOlo6WjpaOlo6WjpaOlo6WjpaOno6ejp6Ono6ejp6Ono6ejp6Ono6RjpGOkY6RjpGOkY6RjpGOkY6RjpkHRIOiQdkg5Jh6RD0iHpkHRIOjQdmg5Nh6ZD06Hp0HRoOjQdmo6ZjpmOmY6ZjpmOmY6ZjpmOmY6ZDkuHpcPSYemwdFg6LB2WDkuHhaM8HkklqSa1pJ40kiRJk2ZSOko6SjpKOko6SjpKOko6ss9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPi/Z5yX7vGSfl+zzkn1ess9L9nnJPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5zX7vGaf1+zzmn1es89r9nnNPq/Z5z6CyKpTTWpJPWkkSZImzSQL8j4/KR2WDkuHpcPSYemwdFg6LBw+qOiiklSTWlJPGkmSpEkzKR0lHSUdJR0lHSUdJR0lHSUdJR0lHTUdNR01HTUdNR01HTUdNR01HTUdLR0tHS0dLR0tHS0dLR0tHS0dLR09HT0dPR09HT0dPR09HT0dPR09HSMdIx0jHSMdIx0jHSMdIx0jHSMdkg5Jh6RD0iHpkHRIOiQdkg5Jh6ZD0+F93pxaUk8aSZKkSTPJgrzPTypJ6ZjpmOmY6ZjpmOmY6ZjpsHRYOiwdlg5Lh6XD0mHpsHRYOHzg0kUlqSa1pJ40kiRJk2ZSOko6SjpKOko6SjpKOko6SjpKOko6ajpqOmo6ajpqOmo6ajpqOmo6ajpaOlo6WjpaOlo6WjpaOlo6WjpaOno6ejp6Ono6ejp6Ono6vM/VaSZZkA+7fzwcC1jBBnZwgAIqOEFLFGyCTbAJNsEm2ASbYBNsgk2xKTbFptgUm2JTbIpNsSm2iW1im9gmtoltYpvYJraJbWIzbIbNsBk2w2bYDJthM2yWNh9OFVjACjawgwMUUMEJYivYCraCrWAr2Aq2gq1gK9gKtoqtYqvYKraKrWKr2Cq2iq1ia9gatoatYWvYGraGrWFr2Bq2jq1j69g6to6tY+vYOraOrWMjSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKluiZJc2xgwMUUMEJWuKZJScWsILYBraBbWA7s6Q7TtASzyw5sYAVbGAHByggNsEm2BSbYlNsik2xKTbFptgUm2Kb2Ca2iW1im9gmtoltYpvYJjbDZtgMm2EzbIbNsBk2w2Zpm48HWMAKNrCDAxRQwQliK9gKtoKtYCvYCraCrWA7s2Q6WuKZJScetvJwrGADOzhAARWcoCV6llyIrWFr2Bq2hq1ha9gatoatY+vYOraOrWPr2Dq2jq1j69gGtoFtYBvYBraBbWAb2Aa2gU2wCTbBJtgEm2ATbIJNsAk2xabYFJtiU2yKTbEpNsWm2Ca2iW1im9gmtoltYpvYJraJzbAZNsNm2AybYTNshs2wWdp8uGFgASvYwA4OUEAFJ4itYCvYCraCrWAr2Aq2gq1gK9gqNrLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBLLLKmPzJL6yCypj8yS+sgsqY/MkvrILKmPzJL6yCypj8yS+nhgK9gKtoKtYCvYCraCrWAr2Aq2iq1iq9gqtoqtYqvYKraKrWJr2Bq2hq1ha9gatoatYWvYGraOrWPr2Dq2jq1j69g6to6tYxvYBraBbWAb2Aa2gW1gG9gGNsEm2ASbYBNsgk2wCTbBJtgUm2JTbIpNsSk2xabYFJtim9gmtoltYpvYJraJbWKb2Ca2M0uaYwEr2MAODlBABSdogeXxAP2qwxwr2MAODlBABSdoiec1zonYCraCrWAr2Aq2gq1gK9gqtoqtYqvYKraKrWKr2Cq2iq1ha9gatoatYWvYGraGrWFr2Dq2jq1j69g6to6tY+vYOraObWAb2EbafODaORHWmZjd0fdDcVRwgpZ4ZuOJBaxgAzs4QGwdW8fWsQ1sA9vANrANbAPbwDawDWwDm2ATbIJNsAk2wSbYBJtgE2yKTbEpNsWm2BSbYlNsik2xTWwT28Q2sU1sE9vENrFNbGc2+m52ZuOJBaxgAzt42M7d07PxQgUneNjqsf/6KLfAw1bVsYIN7OAABVRwgpbo2XghtoKtYCvYPBvrdBRQwQlaomfjhYfNJ7jzsW+BDTxsrTkOUEAFJ2iJ5/STvrznBJQnVrCBbvMlOyeiPFESzxkni6MXM8fjr/Xz3x5/rft281C4UMEJWqKHwoVH3e42D4ULG9hBt/kyeChceNiOmX6qD3QLtEQPhQsLWMHDNsSxgwMU0G2++jwULnSbL6SHwoUFrOBhExd7KFw4QAEVnOBhE18cD4ULC1hBt/lCeihcOEC3+d7noXDhTPSev9CL+a84J6X0ncBb+vq3x5LpsZD9nJHyxAJWsIHHkh3TO1Qf1RYooIITtERv6flwLGAFG3jYZnEcoICHbfqSeUtfaIne0rM7uu2cCNJt6tjADg5QQAUPm50KS/SWvrCAFWxgBwcooILYGraOrWPznjf/xd7zFwqo4AQt0RvSztkwH6ArfBMKiy4surDo3iLmK8pb5EIFJ2iJ3iIXFrCCDewgtoltYpvYJjbDZtj8CGnT0SuY47PC85Lc0QJ9vFdgASvYwA4OUEAFJ4itYCvYCraCrWAr2Aq2gq1gK9gqtoqtYqvYKraKrWKr2Cq2iq1ha9gatoatYWvYGraGrWFr2Dq2jq1j69g6to6tY+vYOraObWAb2Aa2gW1gG9gGtoFtYBvYBJtgE2yCTbAJNsEm2ASbYFNsik2xKTbFptgUm2JTbIptYpvYJraJbWKb2Ca2iW1im9gMm2EzbIbNsBk2w2bYyJJBlghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJ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",
      "brillig_names": [
        "sync_private_state"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "EasyPrivateVoting"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tally",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "vote_ended",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "active_at_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "candidate",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "EasyPrivateVoting::add_to_tally_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "EasyPrivateVoting::add_to_tally_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "candidate",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "EasyPrivateVoting::cast_vote_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "EasyPrivateVoting::cast_vote_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "EasyPrivateVoting::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "EasyPrivateVoting::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "EasyPrivateVoting::end_vote_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "EasyPrivateVoting::end_vote_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "candidate",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "EasyPrivateVoting::get_vote_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "EasyPrivateVoting::get_vote_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "EasyPrivateVoting::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "EasyPrivateVoting::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "EasyPrivateVoting::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "EasyPrivateVoting::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "106": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "108": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ, _) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "109": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "111": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "112": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "113": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "114": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    prelude::AztecAddress,\n    utils::array,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT, hash::poseidon2_hash_with_separator_bounded_vec,\n    traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private_log` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "115": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "116": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "117": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "118": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "134": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "147": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "150": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "155": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "156": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "157": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "158": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "159": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "164": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "165": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "167": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(validateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(bulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "169": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, note nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "172": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "174": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "176": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "184": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes the value.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    /// Reads the value.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n\n    /// Reads the value without checking if the value is initialized.\n    pub fn read_unsafe<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "185": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "199": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "202": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "203": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "205": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "206": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "208": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "210": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "215": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "222": {
      "path": "/Users/daopunk/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "240": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "283": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "300": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "301": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "315": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] != 0 };\n        consumed_counter = 1;\n    } else if typ.is_field() | typ.as_integer().is_some() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type, _) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type, _)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    let serialize_trait: TraitConstraint =\n        quote { Serialize<$serialized_len> }.as_trait_constraint();\n    quote {\n        impl $serialize_trait for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "317": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "318": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "328": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] != 0,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] != 0,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] != 0,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] != 0,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "339": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "353": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[O * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[i * O + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl<let N: u32> Deserialize<0> for () {\n    fn deserialize(_fields: [Field; 0]) -> Self {\n        ()\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..O {\n                fields[i * O + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[O * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "358": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as u8 as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as u16 as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as u32 as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as u64 as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "359": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T, let N: u32> Serialize<N + 1> for Option<T>\nwhere\n    T: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T, let N: u32> Deserialize<N + 1> for Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    fn deserialize(fields: [Field; N + 1]) -> Self {\n        if fields[0] == 1 {\n            let mut value_serialized: [Field; N] = std::mem::zeroed();\n            for i in 0..N {\n                value_serialized[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_serialized))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "377": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, validate_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "380": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "390": {
      "path": "/Users/daopunk/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "/Users/daopunk/desktop/wonder-aztec/aztec-bridge-and-seek/contracts/easy_private_voting/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract EasyPrivateVoting {\n    use dep::aztec:: macros::{\n        functions::{initializer, internal, private, public, utility}, \n        storage::storage\n    };\n    use dep::aztec::keys::getters::get_public_keys;\n    use dep::aztec::prelude::{AztecAddress, Map, PublicImmutable, PublicMutable};\n    use dep::aztec::protocol_types::traits::{Hash, ToField};\n\n    #[storage]\n    struct Storage<Context> {\n        admin: PublicMutable<AztecAddress, Context>, // admin can end vote\n        tally: Map<Field, PublicMutable<Field, Context>, Context>, // we will store candidate as key and number of votes as value\n        vote_ended: PublicMutable<bool, Context>, // vote_ended is boolean\n        active_at_block: PublicImmutable<u32, Context>, // when people can start voting\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress) {\n        storage.admin.write(admin);\n        storage.vote_ended.write(false);\n        storage.active_at_block.initialize(context.block_number() as u32);\n    }\n\n    #[private]\n    fn cast_vote(candidate: Field) {\n        let msg_sender_npk_m_hash = get_public_keys(context.msg_sender()).npk_m.hash();\n\n        let secret = context.request_nsk_app(msg_sender_npk_m_hash); // get secret key of caller of function\n        let nullifier = std::hash::pedersen_hash([context.msg_sender().to_field(), secret]); // derive nullifier from sender and secret\n        context.push_nullifier(nullifier);\n        EasyPrivateVoting::at(context.this_address()).add_to_tally_public(candidate).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn add_to_tally_public(candidate: Field) {\n        assert(storage.vote_ended.read() == false, \"Vote has ended\"); // assert that vote has not ended\n        let new_tally = storage.tally.at(candidate).read() + 1;\n        storage.tally.at(candidate).write(new_tally);\n    }\n\n    #[public]\n    fn end_vote() {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Only admin can end votes\"); // assert that caller is admin\n        storage.vote_ended.write(true);\n    }\n\n    #[utility]\n    unconstrained fn get_vote(candidate: Field) -> Field {\n        storage.tally.at(candidate).read()\n    }\n}"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "61": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{\n    gas::GasOpts, private_context::PrivateContext, public_context::PublicContext,\n    returns_hash::ReturnsHash,\n};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\nuse crate::test::helpers::cheatcodes;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<N>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\npub trait TXEPublicCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEPrivateCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEUtilityCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self) -> T;\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n        returns\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n        returns\n    }\n}\n"
    },
    "68": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        include_by_timestamp::IncludeByTimestamp,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: IncludeByTimestamp,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp =\n            IncludeByTimestamp::min_with_u64(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "69": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> u128 {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> u128 {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "71": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "74": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    // TODO(#2707): Consider making this a u64 as we already cast this to that when encoding the message. This would decrease\n    // the likelihood of collisions without any extra cost.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "76": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "93": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "98": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        authwits::AUTHWIT_TYPES,\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n    let process_message = generate_process_message();\n    generate_authwit_exports();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_authwit_exports() {\n    let authwits = AUTHWIT_TYPES.values();\n    authwits.for_each(|(s): TypeDefinition| { s.add_attribute(\"abi(authwits)\"); });\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "99": {
      "path": "/Users/daopunk/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    }
  }
}
